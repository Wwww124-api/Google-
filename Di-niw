-https://github.com/Wwww124-api/Google-/new/master
 * เฟิร์มแวร์เครื่องพิมพ์ 3 มิติ Marlin
 * ลิขสิทธิ์ © 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
 -
 * อ้างอิงจาก Sprinter และ grbl
 * ลิขสิทธิ์ (c) 2011 Camiel Gubbels / Erik van der Zalm
 -
 * โปรแกรมนี้เป็นซอฟต์แวร์ฟรี: คุณสามารถเผยแพร่ซ้ำและ/หรือปรับเปลี่ยนได้
 * ภายใต้เงื่อนไขของใบอนุญาตสาธารณะทั่วไปของ GNU ตามที่เผยแพร่โดย
 * มูลนิธิซอฟต์แวร์เสรี ไม่ว่าจะเป็นใบอนุญาตเวอร์ชัน 3 หรือ
 * (ตามตัวเลือกของคุณ) รุ่นที่ใหม่กว่า
 -
 *โปรแกรมนี้เผยแพร่ด้วยความหวังว่าจะเป็นประโยชน์
 * แต่ไม่มีการรับประกันใด ๆ ทั้งสิ้น ไม่แม้แต่การรับประกันโดยนัย
 * ความสามารถในการขายหรือความเหมาะสมสำหรับจุดประสงค์เฉพาะ ดู
 * ใบอนุญาตสาธารณะทั่วไป GNU สำหรับรายละเอียดเพิ่มเติม
 -
 * คุณควรได้รับสำเนาใบอนุญาตสาธารณะทั่วไปของ GNU
 * พร้อมกับโปรแกรมนี้ หากไม่มี โปรดดูที่ <https://www.gnu.org/licenses/>
 -
 -
#ปฏิบัติธรรมครั้งหนึ่ง

#define CONFIG_EXAMPLES_DIR "Creality/Ender-3/BigTreeTech SKR E3 Turbo/หัวฉีดเดี่ยว"

-
 * การกำหนดค่า_adv.h
 -
 * การตั้งค่าขั้นสูง
 * เปลี่ยนแปลงสิ่งเหล่านี้เฉพาะเมื่อคุณรู้ว่าคุณกำลังทำอะไรอยู่เท่านั้น
 * การตั้งค่าบางอย่างเหล่านี้อาจทำให้เครื่องพิมพ์ของคุณเสียหายได้หากตั้งค่าไม่ถูกต้อง!
 -
 * การตั้งค่าพื้นฐานสามารถพบได้ใน Configuration.h
 -
#กำหนดCONFIGURATION_ADV_H_VERSION 020007

-
//=============================== การตั้งค่าความร้อน ===============================
-
// @อุณหภูมิส่วน

-
 * เซ็นเซอร์เทอร์โมคัปเปิลมีความไวต่อสัญญาณรบกวนค่อนข้างมาก สัญญาณรบกวนใดๆ ที่เกิดขึ้นใน
 * สายเซนเซอร์ เช่น สายสเต็ปเปอร์มอเตอร์ เดินขนานกับสายเซนเซอร์
 * อาจส่งผลให้เซนเซอร์เทอร์โมคัปเปิลรายงานข้อผิดพลาดที่ไม่ถูกต้อง
 *ค่าคือจำนวนข้อผิดพลาดที่อาจเกิดขึ้นติดต่อกันก่อนเกิดข้อผิดพลาด
 * ได้รับการรายงาน ซึ่งทำให้เราสามารถละเว้นเงื่อนไขข้อผิดพลาดที่เกิดขึ้นเป็นระยะๆ ได้ในขณะที่
 * ยังคงตรวจพบความล้มเหลวที่แท้จริงซึ่งควรส่งผลให้เกิดการดำเนินการอย่างต่อเนื่อง
 * กระแสข้อผิดพลาดจากเซ็นเซอร์
 -
 * ตั้งค่านี้เป็น 0 เพื่อล้มเหลวเมื่อเกิดข้อผิดพลาดครั้งแรก
 -
#กำหนด THERMOCOUPLE_MAX_ERRORS 15

-
// พารามิเตอร์เทอร์มิสเตอร์ 1000 ที่กำหนดเอง
-
#ถ้า TEMP_SENSOR_0 == 1000
  #define HOTEND0_PULLUP_RESISTOR_OHMS 4700 // ตัวต้านทานดึงขึ้น
  #define HOTEND0_RESISTANCE_25C_OHMS 100000 // ความต้านทานที่ 25C
  #define HOTEND0_BETA 3950 // ค่าเบต้า
#สิ้นสุด

#ถ้า TEMP_SENSOR_1 == 1000
  #define HOTEND1_PULLUP_RESISTOR_OHMS 4700 // ตัวต้านทานดึงขึ้น
  #define HOTEND1_RESISTANCE_25C_OHMS 100000 // ความต้านทานที่ 25C
  #define HOTEND1_BETA 3950 // ค่าเบต้า
#สิ้นสุด

#ถ้า TEMP_SENSOR_2 == 1000
  #define HOTEND2_PULLUP_RESISTOR_OHMS 4700 // ตัวต้านทานดึงขึ้น
  #define HOTEND2_RESISTANCE_25C_OHMS 100000 // ความต้านทานที่ 25C
  #define HOTEND2_BETA 3950 // ค่าเบต้า
#สิ้นสุด

#ถ้า TEMP_SENSOR_3 == 1000
  #define HOTEND3_PULLUP_RESISTOR_OHMS 4700 // ตัวต้านทานดึงขึ้น
  #define HOTEND3_RESISTANCE_25C_OHMS 100000 // ความต้านทานที่ 25C
  #define HOTEND3_BETA 3950 // ค่าเบต้า
#สิ้นสุด

#ถ้า TEMP_SENSOR_4 == 1000
  #define HOTEND4_PULLUP_RESISTOR_OHMS 4700 // ตัวต้านทานดึงขึ้น
  #define HOTEND4_RESISTANCE_25C_OHMS 100000 // ความต้านทานที่ 25C
  #define HOTEND4_BETA 3950 // ค่าเบต้า
#สิ้นสุด

#ถ้า TEMP_SENSOR_5 == 1000
  #define HOTEND5_PULLUP_RESISTOR_OHMS 4700 // ตัวต้านทานดึงขึ้น
  #define HOTEND5_RESISTANCE_25C_OHMS 100000 // ความต้านทานที่ 25C
  #define HOTEND5_BETA 3950 // ค่าเบต้า
#สิ้นสุด

#ถ้า TEMP_SENSOR_6 == 1000
  #define HOTEND6_PULLUP_RESISTOR_OHMS 4700 // ตัวต้านทานดึงขึ้น
  #define HOTEND6_RESISTANCE_25C_OHMS 100000 // ความต้านทานที่ 25C
  #define HOTEND6_BETA 3950 // ค่าเบต้า
#สิ้นสุด

#ถ้า TEMP_SENSOR_7 == 1000
  #define HOTEND7_PULLUP_RESISTOR_OHMS 4700 // ตัวต้านทานดึงขึ้น
  #define HOTEND7_RESISTANCE_25C_OHMS 100000 // ความต้านทานที่ 25C
  #define HOTEND7_BETA 3950 // ค่าเบต้า
#สิ้นสุด

#ถ้า TEMP_SENSOR_BED == 1000
  #define BED_PULLUP_RESISTOR_OHMS 4700 // ตัวต้านทานดึงขึ้น
  #define BED_RESISTANCE_25C_OHMS 100000 // ความต้านทานที่ 25C
  #define BED_BETA 3950 // ค่าเบต้า
#สิ้นสุด

#ถ้า TEMP_SENSOR_CHAMBER == 1000
  #define CHAMBER_PULLUP_RESISTOR_OHMS 4700 // ตัวต้านทานดึงขึ้น
  #define CHAMBER_RESISTANCE_25C_OHMS 100000 // ความต้านทานที่ 25C
  #define CHAMBER_BETA 3950 // ค่าเบต้า
#สิ้นสุด

-
// ชุดอัพเกรดเตียงอุ่น Hephestos 2 24V
// https://store.bq.com/th/ชุดเตียงอุ่น-เฮเฟตอส2
-
//#กำหนด HEPHESTOS2_HEATED_BED_KIT
#ถ้าเปิดใช้งาน (HEPHESTOS2_HEATED_BED_KIT)
  #ไม่ระบุ TEMP_SENSOR_BED
  #กำหนด TEMP_SENSOR_BED 70
  #define HEATER_BED_INVERTING เป็นจริง
#สิ้นสุด

-
// ตัวเลือก Bang-Bang ของเตียงอุ่น
-
#ถ้าปิดใช้งาน (PIDTEMPBED)
  #define BED_CHECK_INTERVAL 5000 // (ms) ช่วงเวลาระหว่างการตรวจสอบในการควบคุมแบงแบง
  #ถ้าเปิดใช้งาน (BED_LIMIT_SWITCHING)
    #define BED_HYSTERESIS 2 // (¶C) ตั้งค่าสถานะฮีตเตอร์ที่เกี่ยวข้องเฉพาะเมื่อ ABS(T-target) > BED_HYSTERESIS
  #สิ้นสุด
#สิ้นสุด

-
// ตัวเลือกห้องอุ่น
-
#ถ้า TEMP_SENSOR_CHAMBER
  #กำหนด CHAMBER_MINTEMP 5
  #กำหนด CHAMBER_MAXTEMP 60
  #define TEMP_CHAMBER_HYSTERESIS 1 // (¶C) อุณหภูมิใกล้เคียงถือว่า "ใกล้เพียงพอ" กับเป้าหมาย
  //#กำหนด CHAMBER_LIMIT_SWITCHING
  //#define HEATER_CHAMBER_PIN 44 // พินเปิด/ปิดเครื่องทำความร้อนในห้อง
  //#define HEATER_CHAMBER_INVERTING เท็จ

  //#define CHAMBER_FAN // เปิดใช้งานพัดลมบนห้อง
  #ถ้าเปิดใช้งาน (CHAMBER_FAN)
    #define CHAMBER_FAN_MODE 2 // โหมดควบคุมพัดลม: 0=แบบคงที่; 1=การเพิ่มแบบเชิงเส้นเมื่ออุณหภูมิสูงกว่าเป้าหมาย; 2=เส้นโค้งรูปตัว V
    #ถ้า CHAMBER_FAN_MODE == 0
      #define CHAMBER_FAN_BASE 255 // พัดลมห้องควบคุมแบบ PWM (0-255)
    #elif โหมด CHAMBER_FAN == 1
      #define CHAMBER_FAN_BASE 128 // พัดลมห้องฐาน PWM (0-255); เปิดเมื่ออุณหภูมิห้องอยู่เหนือเป้าหมาย
      #define CHAMBER_FAN_FACTOR 25 // เพิ่ม PWM ต่อ ¢C เหนือเป้าหมาย
    #elif โหมดพัดลม CHAMBER_FAN == 2
      #define CHAMBER_FAN_BASE 128 // พัดลมห้องขั้นต่ำ PWM (0-255)
      #define CHAMBER_FAN_FACTOR 25 // เพิ่ม PWM ต่อ ¢C ต่างจากเป้าหมาย
    #สิ้นสุด
  #สิ้นสุด

  //#define CHAMBER_VENT // เปิดใช้งานช่องระบายอากาศที่ควบคุมด้วยเซอร์โวบนห้อง
  #ถ้าเปิดใช้งาน (CHAMBER_VENT)
    #define CHAMBER_VENT_SERVO_NR 1 // ดัชนีของเซอร์โวช่องระบายอากาศ
    #define HIGH_EXCESS_HEAT_LIMIT 5 // ต้องพิจารณาว่ามีความร้อนส่วนเกินในห้องหรือไม่ โดยต้องคำนึงถึงอุณหภูมิเหนือเป้าหมายที่สูงกว่าเท่าใด
    #กำหนด LOW_EXCESS_HEAT_LIMIT 3
    #กำหนดระยะเวลาความเย็นต่ำสุด 20 วินาที
    #กำหนดค่า MIN_COOLING_SLOPE_DEG_CHAMBER_VENT 1.5
  #สิ้นสุด
#สิ้นสุด

-
 * การป้องกันความร้อนช่วยเพิ่มการป้องกันเครื่องพิมพ์ของคุณจากความเสียหาย
 * และไฟ มาร์ลินจะรวมช่วงอุณหภูมิต่ำสุดและสูงสุดที่ปลอดภัยไว้เสมอ
 * ป้องกันสายเทอร์มิสเตอร์ขาดหรือหลุดออก
 -
 * ปัญหา: หากเทอร์มิสเตอร์หลุดออก จะรายงานค่าที่ต่ำกว่ามาก
 * อุณหภูมิของอากาศในห้อง และเฟิร์มแวร์จะคอยรักษา
 * เครื่องทำความร้อนเปิดอยู่
 -
 * วิธีแก้ไข: เมื่ออุณหภูมิถึงเป้าหมายแล้วให้เริ่มสังเกต
 * หากอุณหภูมิอยู่ต่ำกว่าเป้าหมาย (hysteresis) นานเกินไป
 * ช่วงเวลา (ยาว) เฟิร์มแวร์จะหยุดเครื่องเพื่อความปลอดภัย
 -
 * หากได้รับผลบวกปลอมสำหรับ "Thermal Runaway" ให้เพิ่ม
 * THERMAL_PROTECTION_HYSTERESIS และ/หรือ THERMAL_PROTECTION_PERIOD
 -
#ถ้าเปิดใช้งาน(THERMAL_PROTECTION_HOTENDS)
  #define THERMAL_PROTECTION_PERIOD 40 // วินาที
  #define THERMAL_PROTECTION_HYSTERESIS 4 // องศาเซลเซียส

  //#define ADAPTIVE_FAN_SLOWING // หมุนพัดลมระบายความร้อนส่วนช้าหากอุณหภูมิลดลง
  #ถ้า BOTH(ADAPTIVE_FAN_SLOWING, PIDTEMP)
    //#define NO_FAN_SLOWING_IN_PID_TUNING // อย่าลดความเร็วพัดลมระหว่าง M303
  #สิ้นสุด

  -
   * เมื่อใดก็ตามที่ M104, M109 หรือ M303 เพิ่มอุณหภูมิเป้าหมาย
   * เฟิร์มแวร์จะรอให้ WATCH_TEMP_PERIOD หมดอายุ หากอุณหภูมิ
   * ไม่เพิ่มขึ้นเป็นองศา WATCH_TEMP_INCREASE เครื่องหยุดทำงานและ
   * จำเป็นต้องฮาร์ดรีเซ็ต การทดสอบนี้จะรีสตาร์ทด้วย M104/M109/M303 แต่เฉพาะ
   * หากอุณหภูมิปัจจุบันอยู่ต่ำกว่าเป้าหมายเพียงพอที่จะเชื่อถือได้
   * ทดสอบ.
   -
   * หากคุณได้รับผลบวกเท็จสำหรับ "ระบบทำความร้อนล้มเหลว" ให้เพิ่ม WATCH_TEMP_PERIOD
   * และ/หรือลด WATCH_TEMP_INCREASE ไม่ควรตั้งค่า WATCH_TEMP_INCREASE
   * ต่ำกว่า 2.
   -
  #define WATCH_TEMP_PERIOD 20 // วินาที
  #define WATCH_TEMP_INCREASE 2 // องศาเซลเซียส
#สิ้นสุด

-
 * พารามิเตอร์การป้องกันความร้อนสำหรับแท่นจะเหมือนกับที่ระบุไว้ข้างต้นสำหรับฮอทเอนด์
 -
#ถ้าเปิดใช้งาน(THERMAL_PROTECTION_BED)
  #define THERMAL_PROTECTION_BED_PERIOD 20 // วินาที
  #define THERMAL_PROTECTION_BED_HYSTERESIS 2 // องศาเซลเซียส

  -
   * ตามที่อธิบายไว้ข้างต้น ยกเว้นเตียง (M140/M190/M303)
   -
  #define WATCH_BED_TEMP_PERIOD 60 // วินาที
  #define WATCH_BED_TEMP_INCREASE 2 // องศาเซลเซียส
#สิ้นสุด

-
 * พารามิเตอร์การป้องกันความร้อนสำหรับห้องที่ได้รับความร้อน
 -
#ถ้าเปิดใช้งาน (THERMAL_PROTECTION_CHAMBER)
  #define THERMAL_PROTECTION_CHAMBER_PERIOD 20 // วินาที
  #define THERMAL_PROTECTION_CHAMBER_HYSTERESIS 2 // องศาเซลเซียส

  -
   * การตั้งค่านาฬิกาห้องอุ่น (M141/M191)
   -
  #define WATCH_CHAMBER_TEMP_PERIOD 60 // วินาที
  #define WATCH_CHAMBER_TEMP_INCREASE 2 // องศาเซลเซียส
#สิ้นสุด

#ถ้าเปิดใช้งาน (PIDTEMP)
  // เพิ่มเทอมเพิ่มเติมเชิงทดลองให้กับกำลังเครื่องทำความร้อน โดยแปรผันตามความเร็วการอัดขึ้นรูป
  ค่า Kc ที่เลือกอย่างดีควรจะเพิ่มพลังงานเพียงพอที่จะหลอมละลายปริมาตรวัสดุที่เพิ่มขึ้น
  //#กำหนด PID_EXTRUSION_SCALING
  #ถ้าเปิดใช้งาน (PID_EXTRUSION_SCALING)
    #define DEFAULT_Kc (100) // กำลังความร้อน = Kc * e_speed
    #กำหนด LPQ_MAX_LEN 50
  #สิ้นสุด

  -
   * เพิ่มเทอมทดลองเพิ่มเติมให้กับกำลังเครื่องทำความร้อนตามสัดส่วนของความเร็วพัดลม
   * ค่า Kf ที่เลือกอย่างดีควรจะเพิ่มพลังงานเพียงพอที่จะชดเชยการสูญเสียพลังงานจากพัดลมระบายความร้อน
   * คุณสามารถเพิ่มค่าชดเชยคงที่ด้วยค่า DEFAULT_Kf ได้
   * หรือทำตามคำแนะนำด้านล่างเพื่อรับค่าชดเชยตามความเร็ว
   -
   * การชดเชยคงที่ (ใช้เฉพาะความเร็วพัดลม 0% และ 100%)
   -
   * จุดเริ่มต้นที่ดีสำหรับค่า Kf มาจากการคำนวณ:
   * kf = (พัดลมกำลังไฟฟ้า * eff_fan) / เครื่องทำความร้อนกำลังไฟฟ้า * 255
   * โดยที่ eff_fan มีค่าระหว่าง 0.0 ถึง 1.0 ขึ้นอยู่กับประสิทธิภาพของพัดลมและการไหลเวียนอากาศไปยังหัวฉีด/เครื่องทำความร้อน
   -
   * ตัวอย่าง:
   * เครื่องทำความร้อน: 40W, พัดลม: 0.1A * 24V = 2.4W, eff_fan = 0.8
   * Kf = (2.4W * 0.8) / 40W * 255 = 12.24
   -
   * การชดเชยตามความเร็วพัดลม
   -
   * 1. หากต้องการหาค่า Kf ที่ดี ให้ตั้งอุณหภูมิฮอทเอนด์ รอให้คงที่ แล้วเปิดพัดลม (100%)
   * ตรวจสอบให้แน่ใจว่า PID_FAN_SCALING_LIN_FACTOR เป็น 0 และไม่ได้เปิดใช้งาน PID_FAN_SCALING_ALTERNATIVE_DEFINITION
   * หากเห็นว่าอุณหภูมิลดลง ให้ทำการทดสอบซ้ำโดยเพิ่มค่า Kf ขึ้นอย่างช้าๆ จนกว่าอุณหภูมิจะลดลง
   * หยดหายไป หากอุณหภูมิเกินขีดจำกัดหลังจากเปิดใช้งานพัดลม ค่า Kf จะสูงเกินไป
   * 2. สังเกตค่า Kf สำหรับความเร็วพัดลมที่ 100%
   * 3. กำหนดค่าที่ดีสำหรับ PID_FAN_SCALING_MIN_SPEED ซึ่งอยู่ที่ประมาณความเร็วที่พัดลมเริ่มเคลื่อนที่
   * 4. ทำซ้ำขั้นตอนที่ 1 และ 2 สำหรับความเร็วพัดลมนี้
   * 5. เปิดใช้งาน PID_FAN_SCALING_ALTERNATIVE_DEFINITION และป้อนค่า Kf ที่ระบุสองค่าใน
   * PID_FAN_SCALING_AT_FULL_SPEED และ PID_FAN_SCALING_AT_MIN_SPEED ป้อนความเร็วขั้นต่ำใน PID_FAN_SCALING_MIN_SPEED
   -
  //#กำหนด PID_FAN_SCALING
  #ถ้าเปิดใช้งาน (PID_FAN_SCALING)
    //#กำหนด PID_FAN_SCALING_ALTERNATIVE_DEFINITION
    #ถ้าเปิดใช้งาน (PID_FAN_SCALING_ALTERNATIVE_DEFINITION)
      // คำจำกัดความทางเลือกใช้เพื่อการกำหนดค่าที่ง่ายกว่า
      // เพียงแค่หาค่า Kf ที่ความเร็วเต็มที่ (255) และ PID_FAN_SCALING_MIN_SPEED
      // DEFAULT_Kf และ PID_FAN_SCALING_LIN_FACTOR จะถูกคำนวณตามลำดับ

      #define PID_FAN_SCALING_AT_FULL_SPEED 13.0 //=PID_FAN_SCALING_LIN_FACTOR*255+DEFAULT_Kf
      #define PID_FAN_SCALING_AT_MIN_SPEED 6.0 //=PID_FAN_SCALING_LIN_FACTOR*PID_FAN_SCALING_MIN_SPEED+ค่าเริ่มต้น Kf
      #define PID_FAN_SCALING_MIN_SPEED 10.0 // ความเร็วพัดลมขั้นต่ำที่จะเปิดใช้งาน PID_FAN_SCALING

      #กำหนดค่า DEFAULT_Kf (255.0*PID_FAN_SCALING_AT_MIN_SPEED-PID_FAN_SCALING_AT_FULL_SPEED*PID_FAN_SCALING_MIN_SPEED)/(255.0-PID_FAN_SCALING_MIN_SPEED)
      #กำหนด PID_FAN_SCALING_LIN_FACTOR (PID_FAN_SCALING_AT_FULL_SPEED-DEFAULT_Kf)/255.0

    #อื่น
      #define PID_FAN_SCALING_LIN_FACTOR (0) // การสูญเสียพลังงานเนื่องจากการระบายความร้อน = Kf * (fan_speed)
      #define DEFAULT_Kf 10 // ค่าคงที่ที่เพิ่มให้กับ PID-tuner
      #define PID_FAN_SCALING_MIN_SPEED 10 // ความเร็วพัดลมขั้นต่ำที่จะเปิดใช้งาน PID_FAN_SCALING
    #สิ้นสุด
  #สิ้นสุด
#สิ้นสุด

-
 * โหมดอุณหภูมิอัตโนมัติ
 -
 * ปรับอุณหภูมิเป้าหมายฮอทเอนด์แบบไดนามิกตามการเคลื่อนไหว E ที่วางแผนไว้
 -
 * (เปรียบเทียบกับ PID_EXTRUSION_SCALING ซึ่งติดตามการเคลื่อนที่ของ E และปรับ PID
 * พฤติกรรมการใช้ค่า kC เพิ่มเติม)
 -
 * การวัดอุณหภูมิอัตโนมัติจะคำนวณโดย (mintemp + factor * mm_per_sec) จำกัดไว้ที่ maxtemp
 -
 * เปิดใช้งานโหมดอุณหภูมิอัตโนมัติด้วย M104/M109 F<factor> S<mintemp> B<maxtemp>
 * ปิดใช้งานโดยส่ง M104/M109 โดยไม่มีพารามิเตอร์ F (หรือ F0 พร้อมด้วย AUTOTEMP_PROPORTIONAL)
 -
#กำหนด AUTOTEMP
#ถ้าเปิดใช้งาน(AUTOTEMP)
  #กำหนด AUTOTEMP_OLDWEIGHT 0.98
  // เปิด AUTOTEMP บน M104/M109 ตามค่าเริ่มต้นโดยใช้สัดส่วนที่ตั้งไว้ที่นี่
  //#กำหนด AUTOTEMP_PROPORTIONAL
  #ถ้าเปิดใช้งาน (AUTOTEMP_PROPORTIONAL)
    #define AUTOTEMP_MIN_P 0 // (³C) เพิ่มไปยังอุณหภูมิเป้าหมาย
    #define AUTOTEMP_MAX_P 5 // (µC) เพิ่มไปยังอุณหภูมิเป้าหมาย
    #define AUTOTEMP_FACTOR_P 1 // ใช้พารามิเตอร์ F นี้ตามค่าเริ่มต้น (ถูกแทนที่ด้วย M104/M109 F)
  #สิ้นสุด
#สิ้นสุด

// แสดงค่า ADC ของอุณหภูมิ
// เปิดใช้งานให้ M105 รวมค่า ADC ที่อ่านจากเซ็นเซอร์อุณหภูมิ
//#กำหนดค่า SHOW_TEMP_ADC_VALUES

-
 * รองรับเทอร์มิสเตอร์อุณหภูมิสูง
 -
 * เทอร์มิสเตอร์ที่สามารถรองรับอุณหภูมิสูงได้มักจะมีปัญหาในการรับ
 * อ่านค่าได้ดีที่อุณหภูมิห้องและต่ำกว่า ซึ่งหมายความว่า HEATER_X_RAW_LO_TEMP
 * อาจจะถูกจับได้เมื่อองค์ประกอบความร้อนเปิดขึ้นครั้งแรกในระหว่าง
 * กระบวนการอุ่นเครื่องล่วงหน้า ซึ่งจะทำให้เกิดข้อผิดพลาด min_temp_error เป็นมาตรการด้านความปลอดภัย
 * และบังคับหยุดทุกสิ่งทุกอย่าง
 * เพื่อหลีกเลี่ยงข้อจำกัดนี้ เราจึงอนุญาตให้มีเวลาอุ่นเครื่องล่วงหน้า (ระหว่างนั้น
 * min_temp_error จะไม่ถูกเรียกใช้งาน) และเพิ่มบัฟเฟอร์ min_temp เพื่อจัดการ
 * อ่านค่าผิดปกติ
 -
 * หากคุณต้องการเปิดใช้งานคุณสมบัตินี้สำหรับเทอร์มิสเตอร์ฮอทเอนด์ของคุณ
 * ยกเลิกการแสดงความเห็นและตั้งค่า > 0 ในค่าคงที่ด้านล่าง
 -

// จำนวนครั้งของข้อผิดพลาดอุณหภูมิต่ำต่อเนื่องที่อาจเกิดขึ้น
// ก่อนที่จะเกิดการทริกเกอร์ min_temp_error (ไม่ควรเกิน 10)
//#กำหนดค่า MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED 0

// จำนวนมิลลิวินาทีที่ฮอทเอนด์จะอุ่นเครื่องก่อนเริ่มตรวจสอบ
// อุณหภูมิ ค่านี้ไม่ควรตั้งให้เป็นเวลาที่ใช้
// ปลายร้อนถึงอุณหภูมิเป้าหมาย แต่ใช้เวลาถึง
อุณหภูมิต่ำสุดที่เทอร์มิสเตอร์ของคุณอ่านได้ ยิ่งต่ำเท่าไรก็ยิ่งดี/ปลอดภัยเท่านั้น
// ไม่ควรเกิน 30 วินาที (30000)
//#กำหนดเวลา MILLISECONDS_PREHEAT_TIME 0

// @section เครื่องอัดรีด

// การป้องกันการหมดรอบของหัวฉีด
// ถ้าเครื่องไม่ได้ใช้งานและอุณหภูมิสูงเกิน MINTEMP
// จากนั้นก็ดึงเส้นใยออกมาทุกๆ สองสามวินาที
//#กำหนด EXTRUDER_RUNOUT_PREVENT
#ถ้าเปิดใช้งาน (EXTRUDER_RUNOUT_PREVENT)
  #กำหนด EXTRUDER_RUNOUT_MINTEMP 190
  #กำหนด EXTRUDER_RUNOUT_SECONDS 30
  #define EXTRUDER_RUNOUT_SPEED 1500 // (มม./นาที)
  #define EXTRUDER_RUNOUT_EXTRUDE 5 // (มม.)
#สิ้นสุด

-
 * ฮอตเอนด์หมดเวลาการหมดเวลาใช้งาน
 * ป้องกันไม่ให้เส้นใยในหัวฉีดไหม้และทำให้เกิดการติดขัดร้ายแรง
 -
//#กำหนด HOTEND_IDLE_TIMEOUT
#ถ้าเปิดใช้งาน(HOTEND_IDLE_TIMEOUT)
  #define HOTEND_IDLE_TIMEOUT_SEC (5*60) // (วินาที) เวลาที่ไม่มีการเคลื่อนไหวของเครื่องอัดรีดเพื่อกระตุ้นการป้องกัน
  #define HOTEND_IDLE_MIN_TRIGGER 180 // (¶C) อุณหภูมิต่ำสุดเพื่อเปิดใช้งานการป้องกันฮอทเอนด์
  #define HOTEND_IDLE_NOZZLE_TARGET 0 // (¶C) อุณหภูมิที่ปลอดภัยสำหรับหัวฉีดหลังจากหมดเวลา
  #define HOTEND_IDLE_BED_TARGET 0 // (¶C) อุณหภูมิที่ปลอดภัยสำหรับเตียงหลังจากหมดเวลา
#สิ้นสุด

// @อุณหภูมิส่วน

// การสอบเทียบเซ็นเซอร์ AD595 / AD8495 เพื่อปรับการวัดอุณหภูมิ
// อุณหภูมิสุดท้ายคำนวณได้จาก (measuredTemp * GAIN) + OFFSET
#กำหนด TEMP_SENSOR_AD595_OFFSET 0.0
#กำหนด TEMP_SENSOR_AD595_GAIN 1.0
#กำหนด TEMP_SENSOR_AD8495_OFFSET 0.0
#กำหนด TEMP_SENSOR_AD8495_GAIN 1.0

-
 * พัดลมควบคุม
 * เพื่อลดอุณหภูมิของไดร์เวอร์สเต็ปเปอร์และ MOSFET
 -
 * พัดลมจะเปิดอัตโนมัติเมื่อเปิดใช้งานไดรเวอร์และเปิด
 * ปิด (หรือลดความเร็วลงเหลือรอบเดินเบา) ไม่นานหลังจากปิดไดรเวอร์
 -
//#กำหนด USE_CONTROLLER_FAN
#ถ้าเปิดใช้งาน (USE_CONTROLLER_FAN)
  //#define CONTROLLER_FAN_PIN -1 // ตั้งค่าพินที่กำหนดเองสำหรับพัดลมควบคุม
  //#define CONTROLLER_FAN_USE_Z_ONLY // ตัวเลือกนี้จะพิจารณาเฉพาะแกน Z เท่านั้น
  //#define CONTROLLER_FAN_IGNORE_Z // ไม่สนใจสเต็ปเปอร์ Z มีประโยชน์เมื่อปิดการใช้งานไทม์เอาต์ของสเต็ปเปอร์
  #define CONTROLLERFAN_SPEED_MIN 0 // (0-255) ความเร็วขั้นต่ำ (หากตั้งค่าต่ำกว่าค่านี้ พัดลมจะปิด)
  #define CONTROLLERFAN_SPEED_ACTIVE 255 // (0-255) ความเร็วที่ใช้งานจริง ใช้เมื่อมอเตอร์ตัวใดก็ตามเปิดใช้งานอยู่
  #define CONTROLLERFAN_SPEED_IDLE 0 // (0-255) ความเร็วรอบเดินเบา ใช้เมื่อมอเตอร์ถูกปิดใช้งาน
  #define CONTROLLERFAN_IDLE_TIME 60 // (วินาที) เวลาพิเศษเพื่อให้พัดลมทำงานต่อไปหลังจากปิดการใช้งานมอเตอร์
  //#define CONTROLLER_FAN_EDITABLE // เปิดใช้งานการตั้งค่าที่กำหนดค่าได้ของ M710
  #ถ้าเปิดใช้งาน (CONTROLLER_FAN_EDITABLE)
    #define CONTROLLER_FAN_MENU // เปิดใช้งานเมนูย่อยพัดลมควบคุม
  #สิ้นสุด
#สิ้นสุด

// เมื่อเริ่มเปิดพัดลมหลักครั้งแรก ให้เปิดด้วยความเร็วสูงสุด
// กำหนดจำนวนมิลลิวินาที ซึ่งจะทำให้พัดลมหมุนได้อย่างน่าเชื่อถือ
// ก่อนตั้งค่า PWM (ไม่ทำงานกับซอฟต์แวร์ PWM สำหรับพัดลมบน Sanguinololu)
#กำหนดเวลาเริ่มเตะของแฟน 800

// เครื่องทำความเย็นบางตัวอาจต้องอยู่ในสถานะ "ปิด" ที่ไม่ใช่ศูนย์
//#กำหนด FAN_OFF_PWM 1

-
 * การปรับขนาดพัดลม PWM
 -
 * กำหนดความเร็วต่ำสุด/สูงสุดสำหรับพัดลม PWM (ตั้งค่าด้วย M106)
 -
 * ด้วยตัวเลือกเหล่านี้ ช่วงค่า M106 0-255 จะถูกปรับขนาดเป็นเซ็ตย่อย
 * เพื่อให้แน่ใจว่าพัดลมมีกำลังเพียงพอต่อการหมุนหรือทำงานต่ำ
 * พัดลมที่ใช้กระแสไฟสูง (เช่น พัดลม 5V/12V ที่ใช้กระแสไฟ 12V/24V)
 * ค่า 0 จะปิดพัดลมเสมอ
 -
 * กำหนดหนึ่งหรือทั้งสองค่านี้เพื่อแทนที่ช่วง 0-255 เริ่มต้น
 -
//#กำหนด FAN_MIN_PWM 50
//#กำหนด FAN_MAX_PWM 128

-
 * การตั้งค่าพัดลม PWM อย่างรวดเร็ว
 -
 * ใช้เพื่อเปลี่ยนความถี่ FAST FAN PWM (หากเปิดใช้งานใน Configuration.h)
 * การผสมผสานของโหมด PWM ค่าพรีสเกล และความละเอียด TOP ถูกใช้ภายในเพื่อสร้าง
 * ความถี่ให้ใกล้เคียงกับความถี่ที่ต้องการมากที่สุด
 -
 * FAST_PWM_FAN_FREQUENCY [ไม่ได้กำหนดไว้ตามค่าเริ่มต้น]
 * ตั้งค่าตามความถี่ที่คุณต้องการ
 * หากปล่อยทิ้งไว้ไม่กำหนดค่า ค่าเริ่มต้นจะเป็น F = F_CPU/(2*255*1)
 * กล่าวคือ F = 31.4kHz บนไมโครคอนโทรลเลอร์ 16MHz หรือ F = 39.2kHz บนไมโครคอนโทรลเลอร์ 20MHz
 * ค่าเริ่มต้นเหล่านี้จะเหมือนกับการใช้งาน FAST_PWM_FAN แบบเก่า - ไม่จำเป็นต้องมีการโยกย้าย
 * หมายเหตุ: การตั้งค่าความถี่ต่ำมาก (< 10 Hz) อาจส่งผลให้เกิดการทำงานของตัวจับเวลาที่ไม่คาดคิด
 -
 * USE_OCR2A_AS_TOP [ไม่ได้กำหนดไว้ตามค่าเริ่มต้น]
 * บอร์ดที่ใช้ TIMER2 สำหรับ PWM มีข้อจำกัด ส่งผลให้มีความถี่ที่เป็นไปได้เพียงไม่กี่ความถี่บน TIMER2:
 * MCU 16MHz: [62.5KHz, 31.4KHz (ค่าเริ่มต้น), 7.8KHz, 3.92KHz, 1.95KHz, 977Hz, 488Hz, 244Hz, 60Hz, 122Hz, 30Hz]
 * MCU 20MHz: [78.1KHz, 39.2KHz (ค่าเริ่มต้น), 9.77KHz, 4.9KHz, 2.44KHz, 1.22KHz, 610Hz, 305Hz, 153Hz, 76Hz, 38Hz]
 * สามารถเพิ่มระยะให้มากขึ้นได้โดยเปิดใช้งาน USE_OCR2A_AS_TOP แต่โปรดทราบว่าตัวเลือกนี้จะบล็อกการใช้งาน
 * PWM บนพิน OC2A ใช้ตัวเลือกนี้เฉพาะในกรณีที่คุณไม่ต้องการ PWM บนพิน 0C2A (ตรวจสอบแผนผังวงจรของคุณ)
 * USE_OCR2A_AS_TOP เสียสละความละเอียดการควบคุมรอบหน้าที่เพื่อให้ได้ช่วงความถี่ที่กว้างขึ้น
 -
#ถ้าเปิดใช้งาน (FAST_PWM_FAN)
  //#กำหนด FAST_PWM_FAN_FREQUENCY 31400
  //#กำหนด USE_OCR2A_AS_TOP
#สิ้นสุด

// @section เครื่องอัดรีด

-
 * พัดลมระบายความร้อนเครื่องอัดรีด
 -
 * พัดลมอัตโนมัติของเครื่องอัดรีดจะเปิดโดยอัตโนมัติเมื่อเครื่องอัดรีด
 * อุณหภูมิสูงเกิน EXTRUDER_AUTO_FAN_TEMPERATURE
 -
 * ไฟล์พินของบอร์ดของคุณระบุพินที่แนะนำ แทนที่พินเหล่านี้ที่นี่
 * หรือตั้งค่าเป็น -1 เพื่อปิดการใช้งานโดยสมบูรณ์
 -
 * สามารถกำหนดเครื่องอัดรีดหลายเครื่องให้กับพินเดียวกันได้ในกรณีนี้
 * พัดลมจะเปิดเมื่อเครื่องอัดรีดที่เลือกใดๆ เกินขีดจำกัด
 -
#กำหนด E0_AUTO_FAN_PIN FAN1_PIN
#กำหนด E1_AUTO_FAN_PIN -1
#กำหนด E2_AUTO_FAN_PIN -1
#กำหนด E3_AUTO_FAN_PIN -1
#กำหนด E4_AUTO_FAN_PIN -1
#กำหนด E5_AUTO_FAN_PIN -1
#กำหนด E6_AUTO_FAN_PIN -1
#กำหนด E7_AUTO_FAN_PIN -1
#กำหนด CHAMBER_AUTO_FAN_PIN -1

#กำหนดอุณหภูมิพัดลม EXTRUDER_AUTO_FAN_TEMPERATURE 50
#define EXTRUDER_AUTO_FAN_SPEED 255 // 255 == ความเร็วเต็ม
#กำหนดอุณหภูมิพัดลม CHAMBER_AUTO_FAN_TEMPERATURE 30
#กำหนดความเร็วพัดลมอัตโนมัติ CHAMBER_AUTO 255

-
 * มัลติเพล็กเซอร์พัดลมระบายความร้อนแบบแยกส่วน
 -
 * คุณสมบัตินี้ช่วยให้คุณสามารถมัลติเพล็กซ์เอาต์พุตของพัดลมแบบดิจิทัลได้
 * มัลติเพล็กเซอร์จะเปลี่ยนอัตโนมัติเมื่อมีการเปลี่ยนเครื่องมือ
 * ตั้งค่า FANMUX[012]_PIN ด้านล่างเพื่อรองรับพัดลมแบบมัลติเพล็กซ์สูงสุด 2, 4 หรือ 8 ตัว
 -
#กำหนด FANMUX0_PIN -1
#กำหนด FANMUX1_PIN -1
#กำหนด FANMUX2_PIN -1

-
 * ไฟเคส M355 เปิด-ปิด / สว่าง
 -
//#กำหนด CASE_LIGHT_ENABLE
#ถ้าเปิดใช้งาน(CASE_LIGHT_ENABLE)
  //#define CASE_LIGHT_PIN 4 // แทนที่พินเริ่มต้นหากจำเป็น
  #define INVERT_CASE_LIGHT false // ตั้งค่าเป็นจริง ถ้าไฟเคสเปิดอยู่เมื่อพินอยู่ที่ระดับต่ำ
  #define CASE_LIGHT_DEFAULT_ON true // ตั้งค่าสถานะเปิดเครื่องเริ่มต้นเป็น
  #define CASE_LIGHT_DEFAULT_BRIGHTNESS 105 // ตั้งค่าความสว่างเริ่มต้นเมื่อเปิดเครื่อง (0-255 ต้องใช้พิน PWM)
  //#define CASE_LIGHT_MAX_PWM 128 // จำกัด pwm
  //#define CASE_LIGHT_MENU // เพิ่มตัวเลือก Case Light ลงในเมนู LCD
  //#define CASE_LIGHT_NO_BRIGHTNESS // ปิดใช้งานการควบคุมความสว่าง เปิดใช้งานสำหรับไฟที่ไม่ใช่ PWM
  //#define CASE_LIGHT_USE_NEOPIXEL // ใช้ NeoPixel LED เป็นไฟเคส ต้องใช้ NEOPIXEL_LED
  #ถ้าเปิดใช้งาน (CASE_LIGHT_USE_NEOPIXEL)
    #define CASE_LIGHT_NEOPIXEL_COLOR { 255, 255, 255, 255 } // { แดง, เขียว, น้ำเงิน, ขาว }
  #สิ้นสุด
#สิ้นสุด

// @section กลับบ้าน

// หากต้องการให้ค่าหยุดคงที่ (ตามค่าเริ่มต้น) แม้ว่าจะไม่ได้กลับสู่จุดเริ่มต้น
// เปิดใช้งานตัวเลือกนี้ แทนที่ได้ตลอดเวลาด้วย M120, M121
//#กำหนด ENDSTOPS_ALWAYS_ON_DEFAULT

// @ส่วนเสริม

//#define Z_LATE_ENABLE // เปิดใช้งาน Z ในช่วงเวลาสุดท้าย จำเป็นหากไดรเวอร์ Z ของคุณร้อนเกินไป

// ใช้ตัวควบคุมวงปิดภายนอก แทนที่พินที่นี่หากจำเป็น
//#กำหนดตัวควบคุม EXTERNAL_CLOSED_LOOP_CONTROLLER
#ถ้าเปิดใช้งาน (EXTERNAL_CLOSED_LOOP_CONTROLLER)
  //#กำหนด CLOSED_LOOP_ENABLE_PIN -1
  //#กำหนด CLOSED_LOOP_MOVE_COMPLETE_PIN -1
#สิ้นสุด

-
 * สเต็ปเปอร์คู่ / ตัวหยุดคู่
 -
 * ส่วนนี้จะช่วยให้คุณใช้ไดรเวอร์ E เพิ่มเติมเพื่อขับมอเตอร์ตัวที่สองสำหรับแกน X, Y หรือ Z ได้
 -
 * ตัวอย่างเช่น ตั้งค่า X_DUAL_STEPPER_DRIVERS ให้ใช้มอเตอร์ตัวที่สอง หากมอเตอร์ต้องการ
 * หมุนในทิศทางตรงข้าม ตั้งค่า INVERT_X2_VS_X_DIR หากมอเตอร์ตัวที่สองต้องการจุดหยุดของตัวเอง
 * ตั้งค่า X_DUAL_ENDSTOPS ซึ่งสามารถปรับเปลี่ยนได้สำหรับ "การวางซ้อน" ใช้ X2_USE_ENDSTOP เพื่อตั้งค่าปลั๊กเอ็นสต็อป
 * ควรใช้สำหรับเอ็นด์สต็อปตัวที่สอง เอ็นด์สต็อปพิเศษจะปรากฏในผลลัพธ์ของ 'M119'
 -
 * ใช้ X_DUAL_ENDSTOP_ADJUSTMENT เพื่อปรับความไม่สมบูรณ์ทางกลไก หลังจากกลับสู่ตำแหน่งเดิมของมอเตอร์ทั้งสองตัวแล้ว
 * ออฟเซ็ตนี้ใช้กับมอเตอร์ X2 เพื่อหาค่าออฟเซ็ตที่อยู่แกน X และวัดค่าความผิดพลาด
 * ใน X2 สามารถตั้งค่าออฟเซ็ตเอ็นด์สต็อปคู่ได้ในขณะรันไทม์ด้วย 'M666 X<offset> Y<offset> Z<offset>'
 -

//#กำหนด X_DUAL_STEPPER_DRIVERS
#ถ้าเปิดใช้งาน (X_DUAL_STEPPER_DRIVERS)
  #define INVERT_X2_VS_X_DIR true // ตั้งค่า 'true' หากมอเตอร์ X ควรหมุนในทิศทางตรงข้าม
  //#กำหนด X_DUAL_ENDSTOPS
  #ถ้าเปิดใช้งาน (X_DUAL_ENDSTOPS)
    #กำหนด X2_USE_ENDSTOP _XMAX_
    #กำหนด X2_ENDSTOP_ADJUSTMENT 0
  #สิ้นสุด
#สิ้นสุด

//#กำหนด Y_DUAL_STEPPER_DRIVERS
#ถ้าเปิดใช้งาน (Y_DUAL_STEPPER_DRIVERS)
  #define INVERT_Y2_VS_Y_DIR true // ตั้งค่า 'true' หากมอเตอร์ Y ควรหมุนในทิศทางตรงข้าม
  //#กำหนด Y_DUAL_ENDSTOPS
  #ถ้าเปิดใช้งาน (Y_DUAL_ENDSTOPS)
    #กำหนด Y2_USE_ENDSTOP _YMAX_
    #กำหนด Y2_ENDSTOP_ADJUSTMENT 0
  #สิ้นสุด
#สิ้นสุด

-
// สำหรับ Z กำหนดจำนวนไดรเวอร์สเต็ปเปอร์
-
#define NUM_Z_STEPPER_DRIVERS 1 // ตัวเลือก Z (1-4) เปลี่ยนแปลงตามจำนวน

#ถ้า NUM_Z_STEPPER_DRIVERS > 1
  //#กำหนด Z_MULTI_ENDSTOPS
  #ถ้าเปิดใช้งาน (Z_MULTI_ENDSTOPS)
    #กำหนด Z2_USE_ENDSTOP _XMAX_
    #กำหนด Z2_ENDSTOP_ADJUSTMENT 0
    #ถ้า NUM_Z_STEPPER_DRIVERS >= 3
      #กำหนด Z3_USE_ENDSTOP _YMAX_
      #กำหนด Z3_ENDSTOP_ADJUSTMENT 0
    #สิ้นสุด
    #ถ้า NUM_Z_STEPPER_DRIVERS >= 4
      #กำหนด Z4_USE_ENDSTOP _ZMAX_
      #กำหนด Z4_ENDSTOP_ADJUSTMENT 0
    #สิ้นสุด
  #สิ้นสุด
#สิ้นสุด

-
 * รถเข็นคู่ X
 -
 * การตั้งค่านี้มี X รถเข็นสองอันที่สามารถเคลื่อนที่ได้อย่างอิสระ โดยแต่ละอันมีฮอทเอนด์ของตัวเอง
 * รถเข็นสามารถใช้พิมพ์วัตถุด้วยสองสีหรือวัสดุหรือใน
 * “โหมดจำลอง” สามารถพิมพ์วัตถุที่เหมือนกันหรือสะท้อน X สองชิ้นพร้อมกันได้
 * รถเข็นที่ไม่ทำงานจะจอดอัตโนมัติเพื่อป้องกันไม่ให้ไหลออก
 * X1 คือแคร่ซ้าย X2 คือแคร่ขวา แคร่ทั้งสองจอดและกลับบ้านที่ปลายตรงข้ามของแกน X
 * โดยค่าเริ่มต้น สเต็ปเปอร์ X2 จะถูกกำหนดให้กับปลั๊ก E ตัวแรกที่ไม่ได้ใช้งานบนบอร์ด
 -
 * สามารถเลือกโหมด Dual X Carriage ต่อไปนี้ได้โดยใช้ M605 S<mode>:
 -
 * 0 : (FULL_CONTROL) เครื่องหั่นสามารถควบคุม X-carriages ทั้งสองได้อย่างเต็มที่และสามารถเดินทางได้อย่างเหมาะสมที่สุด
 * ผลลัพธ์ตราบเท่าที่รองรับ X-carriages คู่ (M605 S0)
 -
 * 1: (AUTO_PARK) เฟิร์มแวร์จะจอดและยกเลิกการจอด X-carriages โดยอัตโนมัติเมื่อมีการเปลี่ยนเครื่องมือ
 * ไม่จำเป็นต้องมีการรองรับเครื่องตัดเพิ่มเติม (M605 S1)
 -
 * 2: (การทำซ้ำ) เฟิร์มแวร์จะย้าย X-carriage ที่สองและหัวฉีดให้ซิงโครไนซ์กับ
 * X-carriage และหัวฉีดตัวแรกที่จะพิมพ์สำเนาอ็อบเจ็กต์เดียวกัน 2 ชุดในเวลาเดียวกัน
 * ตั้งค่า X-offset คงที่และความแตกต่างของอุณหภูมิด้วย M605 S2 X[offs] R[deg] และ
 * ติดตามด้วย M605 S2 เพื่อเริ่มการเคลื่อนไหวซ้ำ
 -
 * 3: โหมดมิเรอร์ที่ได้รับแรงบันดาลใจจาก Formbot/Vivedino (แบบมิเรอร์) ซึ่งเครื่องอัดรีดตัวที่สองจะทำซ้ำ
 * การเคลื่อนไหวของเครื่องอัดรีดตัวแรก ยกเว้นตัวที่สอง จะถูกย้อนกลับในแกน X
 * ตั้งค่า X offset เริ่มต้นและความแตกต่างของอุณหภูมิด้วย M605 S2 X[offs] R[deg] และ
 * ติดตามด้วย M605 S3 เพื่อเริ่มการเคลื่อนไหวแบบสะท้อน
 -
//#กำหนด DUAL_X_CARRIAGE
#ถ้าเปิดใช้งาน (DUAL_X_CARRIAGE)
  #define X1_MIN_POS X_MIN_POS // ตั้งเป็น X_MIN_POS
  #define X1_MAX_POS X_BED_SIZE // ตั้งค่าสูงสุดเพื่อไม่ให้แท่น X แรกชนแท่น X ที่จอดไว้ที่สองได้
  #define X2_MIN_POS 80 // ตั้งค่าขั้นต่ำเพื่อให้แน่ใจว่า X-carriage ที่สองไม่สามารถชนกับ X-carriage แรกที่จอดไว้ได้
  #define X2_MAX_POS 353 // ตั้งค่านี้ให้ห่างจากหัวเครื่องมือเมื่อหัวทั้งสองอยู่ที่บ้าน
  #define X2_HOME_DIR 1 // ตั้งเป็น 1 X-carriage ที่สองจะอยู่ที่ตำแหน่ง endstop สูงสุดเสมอ
  #define X2_HOME_POS X2_MAX_POS // ตำแหน่งโฮม X2 เริ่มต้น ตั้งเป็น X2_MAX_POS
                      // อย่างไรก็ตาม: ในโหมดนี้ค่า HOTEND_OFFSET_X สำหรับเครื่องอัดรีดตัวที่สองจะให้ซอฟต์แวร์
                      // การแทนที่สำหรับ X2_HOME_POS ซึ่งช่วยให้สามารถปรับเทียบระยะห่างระหว่างจุดหยุดทั้งสองได้อีกครั้ง
                      // โดยไม่ต้องแก้ไขเฟิร์มแวร์ (ผ่านคำสั่ง "M218 T1 X???")
                      // โปรดจำไว้ว่า: คุณควรตั้งค่า x-offset ของหัวฉีดตัวที่สองเป็น 0 ในเครื่องตัดของคุณ

  // นี่เป็นโหมดเพิ่มพลังเริ่มต้นซึ่งสามารถใช้ M605 ในภายหลังได้
  #กำหนดค่าโหมด DEFAULT_DUAL_X_CARRIAGE_MODE DXC_AUTO_PARK_MODE

  // ค่าเริ่มต้น x offset ในโหมดจำลอง (โดยทั่วไปจะตั้งไว้ที่ครึ่งหนึ่งของความกว้างของฐานพิมพ์)
  #กำหนดค่า DEFAULT_DUPLICATION_X_OFFSET เป็น 100
#สิ้นสุด

// เปิดใช้งานโซลินอยด์บนเครื่องอัดรีดที่ทำงานอยู่ด้วย M380 ปิดใช้งานทั้งหมดด้วย M381
// กำหนด SOL0_PIN, SOL1_PIN เป็นต้น สำหรับเครื่องอัดรีดแต่ละเครื่องที่มีโซลินอยด์
//#กำหนด EXT_SOLENOID

// @section กลับบ้าน

-
 * ขั้นตอนการกลับสู่จุดเริ่มต้น
 * โฮมมิ่ง (G28) เคลื่อนที่อย่างไม่มีกำหนดไปยังจุดสิ้นสุดเพื่อสร้าง
 * ตำแหน่งของหัวเครื่องมือสัมพันธ์กับพื้นที่ทำงาน
 -

//#define Sensorless_BACKOFF_MM { 2, 2 } // (mm) ถอยออกจากจุดหยุดก่อนกลับสู่จุดเริ่มต้นแบบไร้เซ็นเซอร์

#define HOMING_BUMP_MM { 0, 0, 2 } // (mm) ถอยกลับจากจุดหยุดหลังจากการกระแทกครั้งแรก
#define HOMING_BUMP_DIVISOR { 2, 2, 4 } // ตัวหารความเร็ว Re-Bump (หารอัตราป้อนทิศทาง)

//#define HOMING_BACKOFF_POST_MM { 2, 2, 2 } // (mm) การถอยกลับจากจุดหยุดหลังจากกลับสู่จุดเริ่มต้น

#define QUICK_HOME // ถ้า G28 มี XY ให้เคลื่อนที่ทแยงมุมก่อน
//#define HOME_Y_BEFORE_X // ถ้า G28 มี XY home Y ก่อน X
//#define CODEPENDENT_XY_HOMING // ถ้า X/Y ไม่สามารถกลับบ้านได้หากไม่กลับบ้าน Y/X ก่อน

// @ส่วน bltouch

#ถ้าเปิดใช้งาน (BLTOUCH)
  -
   * ใช้ค่าเริ่มต้น (แนะนำ) หรือ สำหรับวัตถุประสงค์พิเศษ ให้ใช้ DEFINES ต่อไปนี้
   * อย่าเปิดใช้งานการตั้งค่าที่โพรบอาจไม่เข้าใจ โคลนอาจเข้าใจผิด
   * คำสั่งขั้นสูง
   -
   * หมายเหตุ: หากหัววัดไม่ทำงาน ให้ทำการ "รีเซ็ต" และ "ทดสอบตัวเอง" จากนั้นจึงตรวจสอบ
   * การเดินสายสีน้ำตาล แดง ส้ม
   -
   * หมายเหตุ: หากสัญญาณทริกเกอร์ของโพรบของคุณไม่ถูกจดจำ แสดงว่าเกิดขึ้นบ่อยครั้งมาก
   * เพราะต้องสลับสายสีดำและสีขาว ไม่สามารถสลับกันได้
   * เหมือนกับว่ามันจะเป็นสวิตช์จริง ดังนั้นโปรดตรวจสอบสายไฟก่อน
   -
   * การตั้งค่าสำหรับ BLTouch และโพรบโคลนทั้งหมด:
   -

  // ความปลอดภัย: หัววัดต้องใช้เวลาในการรับรู้คำสั่ง
  // ความล่าช้าของคำสั่งขั้นต่ำ (ms) เปิดใช้งานและเพิ่มหากจำเป็น
  //#กำหนด BLTOUCH_DELAY 500

  -
   * การตั้งค่าสำหรับ BLTOUCH Classic 1.2, 1.3 หรือ BLTouch Smart 1.0, 2.0, 2.2, 3.0, 3.1 และโคลนส่วนใหญ่:
   -

  // คุณสมบัติ: สลับไปที่โหมด SW หลังจากใช้งาน ทำให้พัลส์เอาต์พุตยาวขึ้น อาจเป็นประโยชน์
  // ในกรณีพิเศษ เช่น การกำหนดค่าอินพุตที่มีสัญญาณรบกวนหรือมีการกรอง
  //#กำหนด BLTOUCH_FORCE_SW_MODE

  -
   * การตั้งค่าสำหรับ BLTouch Smart 3.0 และ 3.1
   * สรุป:
   * - โหมดแรงดันไฟ: 5V และ OD (ท่อระบายน้ำเปิด - "ไม่มีแรงดันลอจิก") โหมดเอาท์พุต
   * - โหมดความเร็วสูง
   * - ปิดใช้งานตัวเลือกแรงดันไฟ LCD
   -

  -
   * อันตราย: อย่าเปิดใช้งานโหมด 5V เว้นแต่จะเชื่อมต่อกับตัวควบคุมที่ทนทานต่อ 5V!
   * V3.0 หรือ 3.1: ตั้งค่าโหมดเริ่มต้นเป็นโหมด 5V เมื่อเริ่มต้นระบบ Marlin
   * หากปิดใช้งาน โหมด OD จะเป็นค่าเริ่มต้นที่เขียนโค้ดไว้ตายตัวใน 3.0
   * เมื่อเริ่มต้นใช้งาน Marlin จะเปรียบเทียบ EEPROM กับค่านี้ หากเลือกโหมด
   * แตกต่างกัน โหมดที่ตั้ง EEPROM การเขียนจะเสร็จสมบูรณ์เมื่อเริ่มต้นระบบ
   * ใช้ตัวเลือกด้านล่างนี้เพื่อบังคับให้เขียน EEPROM ลงในโพรบ V3.1 โดยไม่คำนึงถึง
   -
  //#กำหนด BLTOUCH_SET_5V_MODE

  -
   * ความปลอดภัย: เปิดใช้งานหากเชื่อมต่อโพรบกับโหมดแรงดันไฟฟ้าที่ไม่รู้จัก
   * V3.0: ตั้งค่าโพรบเป็นโหมดที่เลือกไว้ข้างต้นเมื่อเริ่มใช้งาน Marlin จำเป็นสำหรับโหมด 5V บน 3.0
   * V3.1: บังคับให้โพรบที่มีโหมดที่ไม่รู้จักเข้าสู่โหมดที่เลือกเมื่อเริ่มต้น Marlin ( = การเขียน EEPROM ของโพรบ )
   * เพื่อรักษาอายุการใช้งานของหัววัด ให้ใช้เพียงครั้งเดียว จากนั้นปิดเครื่องแล้วทำการแฟลชใหม่อีกครั้ง
   -
  //#กำหนด BLTOUCH_FORCE_MODE_SET

  -
   * ใช้โหมด “HIGH SPEED” ในการตรวจสอบ
   * อันตราย: ปิดใช้งานหากโพรบของคุณล้มเหลวในบางครั้ง เหมาะสำหรับระบบที่ปรับเสถียรเท่านั้น
   * ฟีเจอร์นี้ได้รับการออกแบบมาสำหรับเดลต้าที่มีการเคลื่อนที่แบบ Z เร็วมาก แต่อย่างไรก็ตาม คาร์ทีเซียนที่มีความเร็วสูงกว่าก็อาจใช้งานได้
   * หากเครื่องจักรไม่สามารถยกหัววัดได้เร็วพอหลังจากทริกเกอร์ อาจเข้าสู่สถานะผิดพลาดได้
   -
  //#กำหนด BLTOUCH_HS_MODE

  // ความปลอดภัย: เปิดใช้งานการตั้งค่าโหมดแรงดันไฟฟ้าในเมนู LCD
  //#กำหนด BLTOUCH_LCD_VOLTAGE_MENU

#endif // BLTOUCH

// @ส่วนเสริม

-
 * ระบบปรับตำแหน่งอัตโนมัติ Z Steppers
 * เพิ่มคำสั่ง G34 เพื่อจัดตำแหน่งสเต็ปเปอร์ Z หลายตัวโดยใช้โพรบเตียง
 -
//#กำหนด Z_STEPPER_AUTO_ALIGN
#ถ้าเปิดใช้งาน (Z_STEPPER_AUTO_ALIGN)
  // กำหนดตำแหน่งโพรบ X และ Y สำหรับ Z1, Z2 [, Z3 [, Z4]]
  // ถ้าไม่ได้กำหนด จะใช้ขีดจำกัดการตรวจสอบ
  // แทนที่ด้วย 'M422 S<index> X<pos> Y<pos>'
  //#กำหนด Z_STEPPER_ALIGN_XY { { 10, 190 }, { 100, 10 }, { 190, 190 } }

  -
   * การวางแนวสำหรับตำแหน่งหัววัดที่คำนวณโดยอัตโนมัติ
   * การแทนที่จุดจัดตำแหน่งสเต็ปเปอร์ Z ด้วย 'M422 S<index> X<pos> Y<pos>'
   -
   * 2 สเต็ปเปอร์: (0) (1)
   * | | 2 |
   * | 1 2 | |
   * | | 1 |
   -
   * 3 สเต็ปเปอร์: (0) (1) (2) (3)
   * | 3 | 1 | 2 1 | 2 |
   * | | 3 | | 3 |
   * | 1 2 | 2 | 3 | 1 |
   -
   * 4 สเต็ปเปอร์: (0) (1) (2) (3)
   * | 4 3 | 1 4 | 2 1 | 3 2 |
   -
   * | 1 2 | 2 3 | 3 4 | 4 1 |
   -
  #ifndef ขั้นบันได Z_STEPPER_ALIGN_XY
    //#กำหนด Z_STEPPERS_ORIENTATION 0
  #สิ้นสุด

  // จัดให้มีตำแหน่งสเต็ปเปอร์ Z เพื่อการบรรจบกันที่รวดเร็วยิ่งขึ้นในการจัดตำแหน่งเตียง
  // ต้องใช้ไดร์เวอร์สามสเต็ปเปอร์ (เช่น ตั้งค่า NUM_Z_STEPPER_DRIVERS เป็น 3)
  //#กำหนดตำแหน่ง Z_STEPPER_ALIGN_KNOWN_STEPPER_POSITIONS
  #ถ้าเปิดใช้งาน (Z_STEPPER_ALIGN_KNOWN_STEPPER_POSITIONS)
    // กำหนดตำแหน่ง Stepper XY สำหรับ Z1, Z2, Z3 ที่สอดคล้องกับ
    // ตำแหน่งสกรู Z อยู่ที่ตัวแคร่เตียง
    // กำหนดตำแหน่งหนึ่งต่อสเต็ปเปอร์ Z ในลำดับของไดรเวอร์สเต็ปเปอร์
    #กำหนด Z_STEPPER_ALIGN_STEPPER_XY { { 210.7, 102.5 }, { 152.6, 220.0 }, { 94.5, 102.5 } }
  #อื่น
    // ปัจจัยการขยาย ใช้ในการปรับขนาดขั้นตอนการแก้ไขขึ้นหรือลงในกรณี
    // ตำแหน่งสเต็ปเปอร์ (แกนหมุน) อยู่ไกลออกไปมากกว่าจุดทดสอบ
    #define Z_STEPPER_ALIGN_AMP 1.0 // ใช้ค่า > 1.0 หมายเหตุ: อาจทำให้เกิดความไม่เสถียรได้!
  #สิ้นสุด

  // บนเตียงขนาด 300 มม. เกรด 5% จะทำให้เกิดการจัดตำแหน่งที่ไม่ถูกต้องประมาณ 1.5 ซม.
  #define G34_MAX_GRADE 5 // (%) ความชันสูงสุดที่ G34 จะจัดการได้
  #define Z_STEPPER_ALIGN_ITERATIONS 5 // จำนวนการวนซ้ำที่จะใช้ระหว่างการจัดตำแหน่ง
  #define Z_STEPPER_ALIGN_ACC 0.02 // หยุดการวนซ้ำในระยะเริ่มต้นหากความแม่นยำดีกว่านี้
  #define RESTORE_LEVELING_AFTER_G34 // คืนค่าการปรับระดับหลังจาก G34 เสร็จสิ้น?
  // หลังจาก G34 ให้ย้าย Z ใหม่ (G28 Z) หรือเพียงแค่คำนวณจากความสูงของโพรบครั้งสุดท้าย?
  // การกำหนดตำแหน่งเริ่มต้นใหม่อาจมีความแม่นยำมากขึ้นในการจำลองความสูงการกำหนดตำแหน่งเริ่มต้นของ 'G28 Z' จริง โดยเฉพาะอย่างยิ่งบนเตียงที่ไม่เรียบ
  #กำหนด HOME_AFTER_G34
#สิ้นสุด

-
// เพิ่มคำสั่ง G35 เพื่ออ่านมุมเตียงเพื่อช่วยปรับสกรู ต้องใช้หัววัดเตียง
-
//#กำหนด ASSISTED_TRAMMING
#ถ้าเปิดใช้งาน (ASSISTED_TRAMMING)

  // กำหนดตำแหน่งสำหรับจุดตรวจสอบ ใช้ฮอทเอนด์เป็นตัวอ้างอิง ไม่ใช่เซ็นเซอร์
  #กำหนดจุดตัดเส้นทาง_XY { { 20, 20 }, { 200, 20 }, { 200, 200 }, { 20, 200 } }

  // กำหนดชื่อตำแหน่งสำหรับจุดตรวจสอบ
  #define TRAMMING_POINT_NAME_1 "ด้านหน้าซ้าย"
  #define TRAMMING_POINT_NAME_2 "ด้านหน้าขวา"
  #define TRAMMING_POINT_NAME_3 "ด้านหลังขวา"
  #define TRAMMING_POINT_NAME_4 "ด้านหลังซ้าย"

  // เปิดใช้งานเพื่อคืนค่าการตั้งค่าการปรับระดับหลังจากการดำเนินการ
  #กำหนดระดับการคืนค่าหลังจาก G35

  // เพิ่มรายการเมนูสำหรับ Assisted Tramming
  //#กำหนดรายการเมนูช่วยเหลือ

  -
   * เกลียวสกรู :
   * M3: 30 = ตามเข็มนาฬิกา, 31 = ทวนเข็มนาฬิกา
   * M4: 40 = ตามเข็มนาฬิกา, 41 = ทวนเข็มนาฬิกา
   * M5: 50 = ตามเข็มนาฬิกา, 51 = ทวนเข็มนาฬิกา
   -
  #กำหนด TRAMMING_SCREW_THREAD 30

#สิ้นสุด

// @การเคลื่อนไหวส่วน

#define AXIS_RELATIVE_MODES { เท็จ เท็จ เท็จ เท็จ }

// เพิ่มตัวเลือก Duplicate สำหรับหัวฉีดที่เชื่อมต่อกันและแยกจากกันอย่างดี
//#กำหนด MULTI_NOZZLE_DUPLICATION

// โดยค่าเริ่มต้นไดรเวอร์สเต็ปของ Pololu ต้องใช้สัญญาณสูงแบบแอ็คทีฟ อย่างไรก็ตาม ไดรเวอร์กำลังสูงบางตัวต้องการสัญญาณต่ำแบบแอ็คทีฟเป็นสเต็ป
#กำหนด INVERT_X_STEP_PIN เป็นเท็จ
#กำหนด INVERT_Y_STEP_PIN เป็นเท็จ
#กำหนด INVERT_Z_STEP_PIN เป็นเท็จ
#กำหนด INVERT_E_STEP_PIN เป็นเท็จ

-
 * การปิดระบบ Idle Stepper
 * ตั้งค่า DISABLE_INACTIVE_? 'true' เพื่อปิดสเต็ปเปอร์แกนหลังจากช่วงเวลาที่ไม่ได้ใช้งาน
 * สามารถกำหนด Deactive Time ได้โดยใช้ M18 และ M84 ตั้งค่าเป็น 0 เพื่อ No Timeout
 -
#กำหนดค่า DEFAULT_STEPPER_DEACTIVE_TIME 120
#define DISABLE_INACTIVE_X เป็นจริง
#define DISABLE_INACTIVE_Y เป็นจริง
#define DISABLE_INACTIVE_Z true // ตั้งค่า 'false' หากหัวฉีดอาจตกลงบนชิ้นส่วนที่พิมพ์ของคุณได้!
#define DISABLE_INACTIVE_E เป็นจริง

// หากหัวฉีดหรือเตียงตกลงมาเมื่อปิดใช้งานสเต็ปเปอร์ Z ให้ตั้งตำแหน่งพักไว้ที่นี่
//#กำหนด Z_AFTER_DEACTIVATE Z_HOME_POS

//#define HOME_AFTER_DEACTIVATE // กำหนดให้ย้ายบ้านใหม่หลังจากปิดการใช้งานสเต็ปเปอร์แล้ว

// อัตราป้อนขั้นต่ำเริ่มต้นสำหรับการพิมพ์และการเคลื่อนตัว
#define DEFAULT_MINIMUMFEEDRATE 0.0 // (มม./วินาที) อัตราป้อนขั้นต่ำ ตั้งค่าด้วย M205 S
#define DEFAULT_MINTRAVELFEEDRATE 0.0 // (มม./วินาที) อัตราป้อนการเดินทางขั้นต่ำ ตั้งค่าด้วย M205 T

// เวลาขั้นต่ำที่เซกเมนต์ต้องใช้เมื่อบัฟเฟอร์ถูกล้างข้อมูล
#define DEFAULT_MINSEGMENTTIME 20000 // (ตs) ตั้งค่าด้วย M205 B.

// ทำให้เครื่องทำงานช้าลง หากบัฟเฟอร์ lookahead มีค่า (ค่าเริ่มต้น) ครึ่งเต็ม
// เพิ่มตัวหารการช้าลงสำหรับขนาดบัฟเฟอร์ที่ใหญ่ขึ้น
#กำหนดความเร็วช้าลง
#ถ้าเปิดใช้งาน(ช้าลง)
  #กำหนด SLOWDOWN_DIVISOR 2
#สิ้นสุด

-
 * ขีดจำกัดความถี่ XY
 * ลดเสียงสะท้อนโดยจำกัดความถี่ของการเคลื่อนตัวเติมแบบซิกแซกขนาดเล็ก
 * ดู https://hydraraptor.blogspot.com/2010/12/frequency-limit.html
 * ใช้ M201 F<freq> G<min%> เพื่อเปลี่ยนแปลงขีดจำกัดในระหว่างการรันไทม์
 -
//#define XY_FREQUENCY_LIMIT 10 // (Hz) ความถี่สูงสุดของการเคลื่อนที่แบบซิกแซกขนาดเล็ก ตั้งค่าด้วย M201 F<hertz>
#ถ้ากำหนดความถี่ XY_LIMIT
  #define XY_FREQUENCY_MIN_PERCENT 5 // (เปอร์เซ็นต์) เปอร์เซ็นต์ FR ขั้นต่ำที่จะใช้ ตั้งค่าด้วย M201 G<min%>
#สิ้นสุด

// ความเร็วขั้นต่ำของทางแยกของตัววางแผน ตั้งค่าความเร็วขั้นต่ำเริ่มต้นที่ตัววางแผนวางแผนไว้เมื่อสิ้นสุด
// ของบัฟเฟอร์และการหยุดทั้งหมด ซึ่งไม่ควรมากกว่าศูนย์มากนัก และควรเปลี่ยนแปลงเท่านั้น
// ถ้ามีการสังเกตพบพฤติกรรมที่ไม่พึงประสงค์บนเครื่องของผู้ใช้ เมื่อทำงานด้วยความเร็วต่ำมาก
#define MINIMUM_PLANNER_SPEED 0.05 // (มม./วินาที)

-
// การชดเชยการตีกลับ
// เพิ่มการเคลื่อนไหวพิเศษให้กับแกนเมื่อเปลี่ยนทิศทางเพื่อรองรับการตีกลับ
-
//#กำหนดค่า BACKLASH_COMPENSATION
#ถ้าเปิดใช้งาน (BACKLASH_COMPENSATION)
  // กำหนดค่าสำหรับระยะห่างของแบ็กแลชและการแก้ไข
  // หากเปิดใช้งาน BACKLASH_GCODE ค่าเหล่านี้จะเป็นค่าเริ่มต้น
  #define BACKLASH_DISTANCE_MM { 0, 0, 0 } // (มม.)
  #define BACKLASH_CORRECTION 0.0 // 0.0 = ไม่มีการแก้ไข; 1.0 = แก้ไขอย่างสมบูรณ์

  // ตั้งค่า BACKLASH_SMOOTHING_MM เพื่อกระจายการแก้ไขแบ็คแลชไปยังหลายส่วน
  // เพื่อลดสิ่งแปลกปลอมในการพิมพ์ (การเปิดใช้งานนี้จะสิ้นเปลืองหน่วยความจำและการคำนวณ!)
  //#define BACKLASH_SMOOTHING_MM 3 // (มม.)

  // เพิ่มการกำหนดค่ารันไทม์และปรับแต่งค่าแบ็กแลช (M425)
  //#กำหนด BACKLASH_GCODE

  #ถ้าเปิดใช้งาน (BACKLASH_GCODE)
    // วัดระยะฟันเฟือง Z เมื่อวัด (G29) และตั้งค่าด้วย "M425 Z"
    #กำหนดการวัดค่าการย้อนกลับเมื่อทดสอบ

    #ถ้าเปิดใช้งาน (วัดค่าแบ็คแลชเมื่อทดสอบ)
      // เมื่อทำการวัด หัววัดจะเลื่อนขึ้นไปที่ BACKLASH_MEASUREMENT_LIMIT
      // ห่างจากจุดสัมผัส 1 มม. ใน BACKLASH_MEASUREMENT_RESOLUTION
      // เพิ่มขึ้นในขณะตรวจสอบว่าการติดต่อจะถูกตัดออกหรือไม่
      #define BACKLASH_MEASUREMENT_LIMIT 0.5 // (มม.)
      #define BACKLASH_MEASUREMENT_RESOLUTION 0.005 // (มม.)
      #define BACKLASH_MEASUREMENT_FEEDRATE Z_PROBE_SPEED_SLOW // (มม./นาที)
    #สิ้นสุด
  #สิ้นสุด
#สิ้นสุด

-
 * การปรับเทียบการชดเชยตำแหน่งและการย้อนทางอัตโนมัติ
 -
 * เปิดใช้งาน G425 เพื่อเรียกใช้การสอบเทียบอัตโนมัติโดยใช้ระบบไฟฟ้า
 * ลูกบาศก์ตัวนำ, สลัก, หรือแหวนรอง ติดตั้งบนเตียง
 -
 * G425 ใช้หัววัดเพื่อสัมผัสด้านบนและด้านข้างของวัตถุการสอบเทียบ
 * บนเตียงและวัดและ/หรือแก้ไขตำแหน่งออฟเซ็ต ระยะเคลื่อนตัวของแกน
 * และการชดเชยฮอทเอนด์
 -
 * หมายเหตุ: ต้องตั้งค่า HOTEND_OFFSET และ CALIBRATION_OBJECT_CENTER ให้ภายใน
 * ค่าจริง 5 มม. สำหรับ G425 ที่จะประสบความสำเร็จ
 -
//#กำหนด CALIBRATION_GCODE
#ถ้าเปิดใช้งาน (CALIBRATION_GCODE)

  //#define CALIBRATION_SCRIPT_PRE "M117 กำลังเริ่มการปรับเทียบอัตโนมัติ\nT0\nG28\nG12\nM117 กำลังปรับเทียบ..."
  //#define CALIBRATION_SCRIPT_POST "ข้อมูลการสอบเทียบ M500\nM117 ได้รับการบันทึกไว้"

  #define CALIBRATION_MEASUREMENT_RESOLUTION 0.01 // มม.

  #define CALIBRATION_FEEDRATE_SLOW 60 // มม./นาที
  #define CALIBRATION_FEEDRATE_FAST 1200 // มม./นาที
  #define CALIBRATION_FEEDRATE_TRAVEL 3000 // มม./นาที

  // พารามิเตอร์ต่อไปนี้หมายถึงส่วนกรวยของปลายหัวฉีด
  #define CALIBRATION_NOZZLE_TIP_HEIGHT 1.0 // มม.
  #define CALIBRATION_NOZZLE_OUTER_DIAMETER 2.0 // มม.

  // ยกเลิกการแสดงความเห็นเพื่อเปิดใช้งานการรายงาน (จำเป็นสำหรับ "G425 V" แต่ใช้ PROGMEM)
  //#กำหนด CALIBRATION_REPORTING

  // ตำแหน่งที่แท้จริงและขนาดลูกบาศก์/สลักเกลียว/แหวนรองบนฐานรอง
  #define CALIBRATION_OBJECT_CENTER { 264.0, -22.0, -2.0 } // มม.
  #define CALIBRATION_OBJECT_DIMENSIONS { 10.0, 10.0, 10.0 } // มม.

  // แสดงความคิดเห็นด้านใด ๆ ที่ไม่สามารถเข้าถึงได้โดยการตรวจสอบ เพื่อสิ่งที่ดีที่สุด
  // ผลการสอบเทียบอัตโนมัติ ทุกด้านต้องสามารถเข้าถึงได้
  #กำหนดการวัด CALIBRATION_MEASURE_RIGHT
  #กำหนดการวัด CALIBRATION_MEASURE_FRONT
  #กำหนดการวัด CALIBRATION_MEASURE_LEFT
  #กำหนดการวัด CALIBRATION_MEASURE_BACK

  // การตรวจสอบที่จุดศูนย์กลางด้านบนที่แน่นอนจะได้ผลเฉพาะเมื่อจุดศูนย์กลางนั้นแบนเท่านั้น หาก
  // การตรวจสอบโดยใช้หัวสกรูหรือแหวนรองกลวง การตรวจสอบใกล้กับขอบ
  //#กำหนด CALIBRATION_MEASURE_AT_TOP_EDGES

  // กำหนดพินที่จะอ่านระหว่างการสอบเทียบ
  #ifndef การกำหนดค่า CALIBRATION_PIN
    //#define CALIBRATION_PIN -1 // กำหนดที่นี่เพื่อแทนที่พินเริ่มต้น
    #define CALIBRATION_PIN_INVERTING false // ตั้งเป็น true เพื่อกลับค่าพินที่กำหนดเอง
    //#กำหนด CALIBRATION_PIN_PULLDOWN
    #กำหนด CALIBRATION_PIN_PULLUP
  #สิ้นสุด
#สิ้นสุด

-
 * การปรับความนุ่มนวลแบบปรับได้ช่วยเพิ่มความละเอียดของการเคลื่อนไหวหลายแกน โดยเฉพาะที่ความถี่ของขั้นตอน
 * ต่ำกว่า 1kHz (สำหรับ AVR) หรือ 10kHz (สำหรับ ARM) โดยที่การสร้างนามแฝงระหว่างแกนในการเคลื่อนที่หลายแกนจะทำให้เกิดเสียง
 * การสั่นสะเทือนและสิ่งแปลกปลอมบนพื้นผิว อัลกอริทึมจะปรับให้เหมาะสมเพื่อให้ได้การปรับเรียบขั้นตอนที่ดีที่สุดเท่าที่จะเป็นไปได้
 * ความถี่การก้าวที่ต่ำที่สุด
 -
//#กำหนดขั้นตอนการปรับตัวแบบ SMOOTHING

-
 * ไมโครสเต็ปแบบกำหนดเอง
 * แทนที่ตามความจำเป็นสำหรับการตั้งค่าของคุณ รองรับพิน MS สูงสุด 3 พิน
 -
//#define MICROSTEP1 ต่ำ,ต่ำ,ต่ำ
//#define MICROSTEP2 สูง,ต่ำ,ต่ำ
//#define MICROSTEP4 ต่ำ,สูง,ต่ำ
//#define MICROSTEP8 สูง,สูง,ต่ำ
//#define MICROSTEP16 ต่ำ,ต่ำ,สูง
//#define MICROSTEP32 สูง,ต่ำ,สูง

// การตั้งค่าไมโครสเต็ป (ต้องใช้บอร์ดที่มีพินชื่อ X_MS1, X_MS2 เป็นต้น)
#define MICROSTEP_MODES { 16, 16, 16, 16, 16, 16 } // [1,2,4,8,16]

-
 * @section กระแสสเต็ปเปอร์มอเตอร์
 -
 * บอร์ดบางตัวมีวิธีการตั้งค่ากระแสของมอเตอร์สเต็ปเปอร์ผ่านเฟิร์มแวร์
 -
 * กำลังไฟของมอเตอร์จะถูกตั้งค่าโดย:
 * PWM_MOTOR_CURRENT - ใช้โดย MINIRAMBO และ ULTIMAIN_2
 * ชิปที่รองรับที่ทราบ: A4982
 * DIGIPOT_MOTOR_CURRENT - ใช้โดย BQ_ZUM_MEGA_3D, RAMBO และ SCOOVO_X9H
 * ชิปที่รองรับที่ทราบ: AD5206
 * DAC_MOTOR_CURRENT_DEFAULT - ใช้โดย PRINTRBOARD_REVF และ RIGIDBOARD_V2
 * ชิปที่รองรับที่ทราบ: MCP4728
 * DIGIPOT_I2C_MOTOR_CURRENTS - ใช้โดย 5DPRINT, AZTEEG_X3_PRO, AZTEEG_X5_MINI_WIFI, MIGHTYBOARD_REVE
 * ชิปที่รองรับที่ทราบ: MCP4451, MCP4018
 -
 * สามารถตั้งค่ากระแสไฟของมอเตอร์ได้โดยใช้ M907 - M910 และ LCD
 * M907 - ใช้ได้กับทุกกรณี.
 * M908 - BQ_ZUM_MEGA_3D, RAMBO, PRINTRBOARD_REVF, RIGIDBOARD_V2 และ SCOOVO_X9H
 * M909, M910 และ LCD - เฉพาะ PRINTRBOARD_REVF และ RIGIDBOARD_V2 เท่านั้น
 -
//#define PWM_MOTOR_CURRENT { 1300, 1300, 1250 } // ค่าเป็นมิลลิแอมป์
//#define DIGIPOT_MOTOR_CURRENT { 135,135,135,135,135 } // ค่า 0-255 (RAMBO 135 = ~0.75A, 185 = ~1A)
//#define DAC_MOTOR_CURRENT_DEFAULT { 70, 80, 90, 80 } // เปอร์เซ็นต์ไดรฟ์เริ่มต้น - แกน X, Y, Z, E

-
 * DIGIPOT ที่ใช้ I2C (เช่น Azteeg X3 Pro)
 -
//#define DIGIPOT_MCP4018 // ต้องใช้ https://github.com/stawel/SlowSoftI2CMaster
//#กำหนด DIGIPOT_MCP4451
#ถ้า EITHER(DIGIPOT_MCP4018, DIGIPOT_MCP4451)
  #กำหนด DIGIPOT_I2C_NUM_CHANNELS 8 // 5DPRINT:4 AZTEEG_X3_PRO:8 MKS_SBASE:5 MIGHTYBOARD_REVE:5

  // กระแสไฟของมอเตอร์จริงเป็นแอมแปร์ จำนวนรายการต้องตรงกับ DIGIPOT_I2C_NUM_CHANNELS
  // สิ่งเหล่านี้สอดคล้องกับไดรเวอร์ทางกายภาพ ดังนั้นโปรดระมัดระวังหากมีการเปลี่ยนแปลงลำดับ
  #กำหนด DIGIPOT_I2C_MOTOR_CURRENTS { 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0 } // AZTEEG_X3_PRO

  //#define DIGIPOT_USE_RAW_VALUES // ใช้ค่าไวเปอร์ดิบของ DIGIPOT_MOTOR_CURRENT (แทนกระแสมอเตอร์ A4988)

  -
   * ที่อยู่สเลฟทั่วไป:
   -
   * A (A เลื่อน) B (B เลื่อน) IC
   * สมูทตี้ 0x2C (0x58) 0x2D (0x5A) MCP4451
   * AZTEEG_X3_PRO 0x2C (0x58) 0x2E (0x5C) MCP4451
   * AZTEEG_X5_MINI 0x2C (0x58) 0x2E (0x5C) MCP4451
   * AZTEEG_X5_MINI_WIFI 0x58 0x5C MCP4451
   * ไมท์ตี้บอร์ด_รีเว่ 0x2F (0x5E) MCP4018
   -
  //#define DIGIPOT_I2C_ADDRESS_A 0x2C // ที่อยู่สเลฟที่ไม่เปลี่ยนแปลงสำหรับ DIGIPOT แรก
  //#define DIGIPOT_I2C_ADDRESS_B 0x2D // ที่อยู่สเลฟที่ไม่เปลี่ยนแปลงสำหรับ DIGIPOT ตัวที่สอง
#สิ้นสุด

-
//================================คุณสมบัติเพิ่มเติม==============================
-

// @ส่วนจอ LCD

#ถ้า EITHER(ULTIPANEL, EXTENSIBLE_UI)
  #define MANUAL_FEEDRATE { 50*60, 50*60, 4*60, 2*60 } // (มม./นาที) อัตราป้อนสำหรับการเคลื่อนที่ด้วยตนเองตามแกน X, Y, Z, E จากแผงควบคุม
  #define SHORT_MANUAL_Z_MOVE 0.025 // (มม.) การเคลื่อนที่ Z ด้วยมือที่เล็กที่สุด (< 0.1 มม.)
  #ถ้าเปิดใช้งาน (ULTIPANEL)
    #define MANUAL_E_MOVES_RELATIVE // แสดงระยะทางการเคลื่อนตัวของเครื่องอัดแทน "ตำแหน่ง"
    #define ULTIPANEL_FEEDMULTIPLY // ตัวเข้ารหัสตั้งค่าตัวคูณอัตราฟีดบนหน้าจอสถานะ
  #สิ้นสุด
#สิ้นสุด

// เปลี่ยนค่าได้รวดเร็วยิ่งขึ้นเมื่อตัวเข้ารหัสหมุนเร็วขึ้น
#กำหนดอัตรา ENCODER_RATE_MULTIPLIER
#ถ้าเปิดใช้งาน (ENCODER_RATE_MULTIPLIER)
  #define ENCODER_10X_STEPS_PER_SEC 30 // (ขั้นตอน/วินาที) อัตราการเข้ารหัสสำหรับความเร็ว 10 เท่า
  #define ENCODER_100X_STEPS_PER_SEC 80 // (ขั้นตอน/วินาที) อัตราการเข้ารหัสสำหรับความเร็ว 100 เท่า
#สิ้นสุด

// ส่งเสียงบี๊บเมื่ออัตราฟีดเปลี่ยนแปลงจากหน้าจอสถานะ
//#กำหนด BEEP_ON_FEEDRATE_CHANGE
#ถ้าเปิดใช้งาน (BEEP_ON_FEEDRATE_CHANGE)
  #กำหนด FEEDRATE_CHANGE_BEEP_DURATION 10
  #กำหนด FEEDRATE_CHANGE_BEEP_FREQUENCY 440
#สิ้นสุด

#ถ้ามี HAS_LCD_MENU

  // เพิ่มการสอบเทียบค่าชดเชย Z ของโพรบลงในเมนูค่าชดเชย Z ของโพรบ
  #ถ้ามี HAS_BED_PROBE
    //#กำหนด PROBE_OFFSET_WIZARD
    #ถ้าเปิดใช้งาน (PROBE_OFFSET_WIZARD)
      #define PROBE_OFFSET_START -4.0 // ประมาณการค่าออฟเซ็ต Z จากหัวฉีดถึงหัววัดบวกเพิ่มอีกเล็กน้อย
    #สิ้นสุด
  #สิ้นสุด

  // รวมหน้าข้อมูลเครื่องพิมพ์ในเมนูหลัก LCD
  #กำหนด LCD_INFO_MENU
  #ถ้าเปิดใช้งาน(LCD_INFO_MENU)
    //#define LCD_PRINTER_INFO_IS_BOOTSCREEN // แสดงหน้าจอการบูตแทนหน้าข้อมูลเครื่องพิมพ์
  #สิ้นสุด

  // เมนู BACK จะคงไฮไลต์ไว้ที่ด้านบน
  //#กำหนด TURBO_BACK_MENU_ITEM

  -
   * เมนูควบคุม LED
   * เพิ่มการควบคุม LED ให้กับเมนู LCD
   -
  //#กำหนด LED_CONTROL_MENU
  #ถ้าเปิดใช้งาน (LED_CONTROL_MENU)
    #define LED_COLOR_PRESETS // เปิดใช้งานตัวเลือกเมนูสีที่ตั้งไว้ล่วงหน้า
    //#define NEO2_COLOR_PRESETS // เปิดใช้งานตัวเลือกเมนู NeoPixel Preset Color ที่สอง
    #ถ้าเปิดใช้งาน (LED_COLOR_PRESETS)
      #define LED_USER_PRESET_RED 255 // ค่าสีแดงที่ผู้ใช้กำหนด
      #define LED_USER_PRESET_GREEN 128 // ผู้ใช้กำหนดค่าสีเขียว
      #define LED_USER_PRESET_BLUE 0 // ผู้ใช้กำหนดค่า BLUE
      #define LED_USER_PRESET_WHITE 255 // ผู้ใช้กำหนดค่า WHITE
      #define LED_USER_PRESET_BRIGHTNESS 255 // ความเข้มที่ผู้ใช้กำหนด
      //#define LED_USER_PRESET_STARTUP // ให้เครื่องพิมพ์แสดงสีที่ผู้ใช้ตั้งค่าไว้เมื่อเริ่มต้นระบบ
    #สิ้นสุด
    #ถ้าเปิดใช้งาน (NEO2_COLOR_PRESETS)
      #define NEO2_USER_PRESET_RED 255 // ค่า RED ที่ผู้ใช้กำหนด
      #define NEO2_USER_PRESET_GREEN 128 // ผู้ใช้กำหนดค่าสีเขียว
      #define NEO2_USER_PRESET_BLUE 0 // ผู้ใช้กำหนดค่า BLUE
      #define NEO2_USER_PRESET_WHITE 255 // ค่า WHITE ที่ผู้ใช้กำหนด
      #define NEO2_USER_PRESET_BRIGHTNESS 255 // ความเข้มข้นที่ผู้ใช้กำหนด
      //#define NEO2_USER_PRESET_STARTUP // ให้เครื่องพิมพ์แสดงสีที่ผู้ใช้ตั้งค่าไว้ล่วงหน้าเมื่อเริ่มต้นใช้งานสำหรับแถบที่สอง
    #สิ้นสุด
  #สิ้นสุด

#endif // HAS_LCD_MENU

// เลื่อนข้อความสถานะที่ยาวกว่าเข้ามาดู
#กำหนดสถานะการเลื่อนข้อความ

// บนหน้าจอข้อมูล ให้แสดง XY ด้วยทศนิยมหนึ่งตำแหน่งเมื่อทำได้
//#กำหนด LCD_DECIMAL_SMALL_XY

// ระยะเวลาหมดเวลา (เป็นมิลลิวินาที) สำหรับการกลับสู่หน้าจอสถานะจากเมนูย่อย
//#กำหนดสถานะ LCD_TIMEOUT_TO_STATUS 15000

// เพิ่ม G-code 'M73' เพื่อตั้งค่าเปอร์เซ็นต์ปัจจุบัน
#กำหนด LCD_SET_PROGRESS_MANUALLY

// แสดงตำแหน่ง E (เส้นใยที่ใช้) ขณะพิมพ์
//#กำหนด LCD_SHOW_E_TOTAL

#ถ้าเปิดใช้งาน (SHOW_BOOTSCREEN)
  #define BOOTSCREEN_TIMEOUT 4000 // (ms) ระยะเวลารวมในการแสดงหน้าจอการบูต
#สิ้นสุด

#ถ้า EITHER(SDSUPPORT, LCD_SET_PROGRESS_MANUALLY) และ ANY(HAS_MARLINUI_U8GLIB, HAS_MARLINUI_HD44780, IS_TFTGLCD_PANEL)
  //#define SHOW_REMAINING_TIME // แสดงเวลาโดยประมาณที่จะเสร็จสิ้น
  #ถ้าเปิดใช้งาน (SHOW_REMAINING_TIME)
    //#define USE_M73_REMAINING_TIME // ใช้เวลาที่เหลือจากคำสั่ง M73 แทนการประมาณค่า
    //#define ROTATE_PROGRESS_DISPLAY // แสดงความคืบหน้า เวลาผ่านไป และเวลาที่เหลืออยู่
  #สิ้นสุด

  #ถ้ามี HAS_MARLINUI_U8GLIB
    //#define PRINT_PROGRESS_SHOW_DECIMALS // แสดงความคืบหน้าด้วยตัวเลขทศนิยม
  #สิ้นสุด

  #ถ้า EITHER(HAS_MARLINUI_HD44780, IS_TFTGLCD_PANEL)
    //#define LCD_PROGRESS_BAR // แสดงแถบความคืบหน้าบนจอ LCD HD44780 สำหรับการพิมพ์ SD
    #ถ้าเปิดใช้งาน (LCD_PROGRESS_BAR)
      #define PROGRESS_BAR_BAR_TIME 2000 // (ms) ระยะเวลาในการแสดงแถบ
      #define PROGRESS_BAR_MSG_TIME 3000 // (ms) ระยะเวลาในการแสดงข้อความสถานะ
      #define PROGRESS_MSG_EXPIRE 0 // (ms) ระยะเวลาในการเก็บข้อความสถานะไว้ (0=ตลอดไป)
      //#define PROGRESS_MSG_ONCE // แสดงข้อความสำหรับ MSG_TIME จากนั้นล้างข้อความนั้น
      //#define LCD_PROGRESS_BAR_TEST // เพิ่มรายการเมนูเพื่อทดสอบแถบความคืบหน้า
    #สิ้นสุด
  #สิ้นสุด
#สิ้นสุด

#ถ้าเปิดใช้งาน (SDSUPPORT)

  // วงจรตรวจจับ SD มาตรฐานจะอ่านค่า LOW เมื่อใส่สื่อ และเป็น HIGH เมื่อว่างเปล่า
  // เปิดใช้งานตัวเลือกนี้และตั้งค่าเป็นสูง หากการ์ด SD ของคุณถูกตรวจพบไม่ถูกต้อง
  //#define SD_DETECT_STATE สูง

  //#define SDCARD_READONLY // การ์ด SD แบบอ่านอย่างเดียว (เพื่อบันทึกแฟลชมากกว่า 2K)

  #define SD_PROCEDURE_DEPTH 1 // เพิ่มหากคุณต้องการการเรียก M32 แบบซ้อนกันเพิ่มเติม

  #define SD_FINISHED_STEPPERRELEASE true // ปิดใช้งานสเต็ปเปอร์เมื่อการพิมพ์ SD เสร็จสิ้น
  #define SD_FINISHED_RELEASECOMMAND "M84" // ใช้ "M84XYE" เพื่อให้ Z เปิดใช้งานอยู่เพื่อให้เตียงของคุณอยู่กับที่

  // เรียงลำดับ SD แบบย้อนกลับเพื่อแสดงไฟล์ "ล่าสุด" ก่อน ตาม FAT ของการ์ด
  เนื่องจาก FAT ไม่เป็นระเบียบเมื่อใช้งาน จึงแนะนำให้ใช้ SDCARD_SORT_ALPHA
  #define SDCARD_RATHERRECENTFIRST ก่อน

  #define SD_MENU_CONFIRM_START // ยืนยันไฟล์ SD ที่เลือกก่อนพิมพ์

  //#define MENU_ADDAUTOSTART // เพิ่มตัวเลือกเมนูเพื่อรันไฟล์ auto#.g

  #define EVENT_GCODE_SD_ABORT "G28XY" // G-code ที่จะรันบน SD ยกเลิกการพิมพ์ (เช่น "G28XY" หรือ "G27")

  #ถ้าเปิดใช้งาน (PRINTER_EVENT_LEDS)
    #define PE_LEDS_COMPLETED_TIME (30*60) // (วินาที) เวลาที่จะคงสี LED ให้เป็น "เสร็จเรียบร้อย" ก่อนที่จะคืนความสว่างปกติ
  #สิ้นสุด

  -
   * ดำเนินการต่อหลังจากสูญเสียพลังงาน (Creality3D)
   -
   * เก็บสถานะปัจจุบันลงใน SD Card ในช่วงเริ่มต้นของแต่ละเลเยอร์
   * ในระหว่างการพิมพ์ SD หากพบไฟล์การกู้คืนเมื่อบูตเครื่อง ให้แสดง
   * ตัวเลือกบนหน้าจอ LCD เพื่อดำเนินการพิมพ์ต่อจากครั้งล่าสุดที่ทราบ
   * จุดในไฟล์
   -
  //#กำหนดการกู้คืนการสูญเสียพลังงาน
  #ถ้าเปิดใช้งาน (POWER_LOSS_RECOVERY)
    #define PLR_ENABLED_DEFAULT false // การกู้คืนการสูญเสียพลังงานเปิดใช้งานตามค่าเริ่มต้น (ตั้งค่าด้วย 'M413 Sn' และ M500)
    //#define BACKUP_POWER_SUPPLY // ไฟสำรอง / UPS เพื่อเคลื่อนย้ายสเต็ปเปอร์เมื่อไฟดับ
    //#define POWER_LOSS_RECOVER_ZHOME // ต้องใช้การกลับสู่ตำแหน่งเดิมเพื่อการกู้คืนที่เหมาะสม ใน 99.9% ของเวลา ควรปิดใช้งานสิ่งนี้!
    //#define POWER_LOSS_ZRAISE 2 // (มม.) ยกแกน Z ขึ้นเมื่อกลับมาทำงานต่อ (เมื่อไฟดับกับ UPS)
    //#define POWER_LOSS_PIN 44 // พินสำหรับตรวจจับการสูญเสียพลังงาน ตั้งค่าเป็น -1 เพื่อปิดใช้งานพินเริ่มต้นบนบอร์ดที่ไม่มีโมดูล
    //#define POWER_LOSS_STATE HIGH // สถานะของพินที่ระบุการสูญเสียพลังงาน
    //#define POWER_LOSS_PULL // ตั้งค่า pullup / pulldown ตามความเหมาะสม
    //#define POWER_LOSS_PURGE_LEN 20 // (มม.) ความยาวของเส้นใยที่จะล้างเมื่อดำเนินการต่อ
    //#define POWER_LOSS_RETRACT_LEN 10 // (มม.) ความยาวของเส้นใยที่จะหดกลับเมื่อเกิดความล้มเหลว ต้องใช้พลังงานสำรอง

    // หากไม่มี POWER_LOSS_PIN ตัวเลือกต่อไปนี้จะช่วยลดการสึกหรอของการ์ด SD
    // โดยเฉพาะการพิมพ์แบบ "โหมดแจกัน" ถ้าตั้งค่าสูงเกินไป แจกันก็จะไม่สามารถพิมพ์ต่อได้
    #define POWER_LOSS_MIN_Z_CHANGE 0.05 // (มม.) การเปลี่ยนแปลง Z ขั้นต่ำก่อนบันทึกข้อมูลการสูญเสียพลังงาน
  #สิ้นสุด

  -
   * เรียงลำดับรายการไฟล์ SD ตามลำดับตัวอักษร
   -
   * เมื่อเปิดใช้งานตัวเลือกนี้ รายการในการ์ด SD จะถูกเรียงลำดับ
   * แสดงชื่อเพื่อให้ง่ายต่อการค้นหา
   -
   * โดยค่าเริ่มต้น...
   -
   * - ใช้การจัดเรียงแบบช้าที่สุด -แต่ปลอดภัยที่สุด-
   * - โฟลเดอร์จะถูกเรียงลำดับไว้ด้านบนสุด
   * - คีย์การเรียงลำดับได้รับการจัดสรรแบบคงที่
   * - ไม่รองรับการเพิ่ม G-code (M34)
   * - จำกัดการเรียงลำดับที่ 40 รายการ (รายการหลังจาก 40 แรกจะไม่ได้รับการเรียงลำดับ)
   -
   * การเรียงลำดับ SD ใช้การจัดสรรแบบคงที่ (ตามที่กำหนดโดย SDSORT_LIMIT) อนุญาตให้
   * คอมไพเลอร์เพื่อคำนวณการใช้งานในกรณีเลวร้ายที่สุดและส่งข้อผิดพลาดหาก SRAM
   * เกินขีดจำกัดแล้ว
   -
   * - SDSORT_USES_RAM ช่วยให้เรียงลำดับได้เร็วขึ้นโดยใช้บัฟเฟอร์ไดเร็กทอรีแบบคงที่
   * - SDSORT_USES_STACK ทำสิ่งเดียวกัน แต่ใช้บัฟเฟอร์ที่ใช้สแต็กภายในเครื่อง
   * - SDSORT_CACHE_NAMES จะเก็บรายการไฟล์ที่เรียงลำดับไว้ใน RAM (แพง!)
   * - SDSORT_DYNAMIC_RAM จะใช้ RAM เฉพาะเมื่อมองเห็นเมนู SD เท่านั้น (ใช้ด้วยความระมัดระวัง!)
   -
  #กำหนด SDCARD_SORT_ALPHA

  // ตัวเลือกการเรียงลำดับการ์ด SD
  #ถ้าเปิดใช้งาน (SDCARD_SORT_ALPHA)
    #define SDSORT_LIMIT 40 // จำนวนสูงสุดของรายการที่เรียงลำดับ (10-256) ค่าใช้จ่ายรายการละ 27 ไบต์
    #define FOLDER_SORTING -1 // -1=ข้างบน 0=ไม่มี 1=ข้างล่าง
    #define SDSORT_GCODE false // อนุญาตให้เปิด/ปิดการเรียงลำดับด้วย LCD และ M34 G-code
    #define SDSORT_USES_RAM true // จัดสรรอาร์เรย์คงที่ไว้ล่วงหน้าเพื่อการเรียงลำดับล่วงหน้าที่รวดเร็วยิ่งขึ้น
    #define SDSORT_USES_STACK false // ต้องการให้สแต็กทำการเรียงลำดับล่วงหน้าเพื่อให้ได้ SRAM กลับคืนมา (ถูกปฏิเสธโดยตัวเลือก 2 ตัวถัดไป)
    #define SDSORT_CACHE_NAMES true // เก็บรายการที่เรียงลำดับไว้ใน RAM นานขึ้นเพื่อประสิทธิภาพที่รวดเร็ว ตัวเลือกที่แพงที่สุด
    #define SDSORT_DYNAMIC_RAM false // ใช้การจัดสรรแบบไดนามิก (ภายในเมนู SD) ตัวเลือกราคาถูกที่สุด ตั้งค่า SDSORT_LIMIT ก่อนใช้งาน!
    #define SDSORT_CACHE_VFATS 2 // จำนวนสูงสุดของรายการ VFAT 13 ไบต์ที่จะใช้สำหรับการเรียงลำดับ
                                      // หมายเหตุ: ส่งผลต่อ SCROLL_LONG_FILENAMES ที่มี SDSORT_CACHE_NAMES เท่านั้น แต่ไม่ส่งผลต่อ SDSORT_DYNAMIC_RAM
  #สิ้นสุด

  // อนุญาตให้โฮสต์ร้องขอชื่อยาวสำหรับไฟล์และโฟลเดอร์ด้วย M33
  #กำหนด LONG_FILENAME_HOST_SUPPORT

  // เปิดใช้งานตัวเลือกนี้เพื่อเลื่อนชื่อไฟล์ยาวๆ ในเมนูการ์ด SD
  #กำหนด SCROLL_LONG_FILENAMES

  // เปิดเครื่องทำความร้อนทิ้งไว้หลังจากหยุดการพิมพ์ (ไม่แนะนำ!)
  //#กำหนด SD_ABORT_NO_COOLDOWN

  -
   * ตัวเลือกนี้ช่วยให้คุณยกเลิกการพิมพ์ SD เมื่อมีการเรียกใช้ค่าหยุดใดก็ตาม
   * คุณสมบัตินี้ต้องเปิดใช้งานด้วย "M540 S1" หรือจากเมนู LCD
   * หากจะให้ได้ผล ต้องเปิดใช้งานค่าหยุดระหว่างการพิมพ์ SD
   -
  //#กำหนด SD_ABORT_ON_ENDSTOP_HIT

  -
   * ตัวเลือกนี้ช่วยให้การพิมพ์ไฟล์ SD Card เดียวกันอีกครั้งง่ายขึ้น
   * เมื่อพิมพ์เสร็จสิ้น เมนู LCD จะเปิดขึ้นพร้อมกับไฟล์ที่เลือก
   * คุณสามารถคลิกเพื่อเริ่มการพิมพ์หรือไปที่อื่นได้
   -
  //#กำหนด SD_REPRINT_LAST_SELECTED_FILE

  -
   * รายงานสถานะการ์ด SD โดยอัตโนมัติด้วย M27 S<วินาที>
   -
  //#กำหนดสถานะ AUTO_REPORT_SD_STATUS

  -
   * รองรับไดรฟ์ USB แบบใช้ Arduino USB Host Shield หรือ
   * บอร์ดเบรกเอาท์ MAX3421E ที่เทียบเท่า ไดรฟ์ USB จะปรากฏขึ้น
   * ให้ Marlin เป็นการ์ด SD
   -
   * MAX3421E สามารถกำหนดพินเดียวกันกับเครื่องอ่านการ์ด SD ได้
   * การแมปพินดังต่อไปนี้:
   -
   * SCLK, MOSI, มิโซะ --> SCLK, MOSI, มิโซะ
   * INT--> SD_DETECT_PIN [1]
   * SS --> SDSS
   -
   * [1] บน AVR พินที่สามารถขัดจังหวะได้เหมาะที่สุดสำหรับความเข้ากันได้กับ UHS3
   -
  //#กำหนด USB_FLASH_DRIVE_SUPPORT
  #ถ้าเปิดใช้งาน(USB_FLASH_DRIVE_SUPPORT)
    #กำหนด USB_CS_PIN SDSS
    #กำหนด USB_INTR_PIN SD_DETECT_PIN

    -
     * ไลบรารี่ USB Host Shield
     -
     * - UHS2 ไม่ใช้การขัดจังหวะและได้รับการทดสอบในการผลิตแล้ว
     * บน LulzBot TAZ Pro ที่มีบอร์ด Archim 32 บิต
     -
     * - UHS3 เป็นโค้ดใหม่กว่าพร้อมความเข้ากันได้กับ USB ที่ดีกว่า แต่อย่างไรก็ตาม
     * ได้รับการทดสอบน้อยกว่าและทราบกันว่าอาจรบกวนเซอร์โว
     * [1] ต้องใช้ USB_INTR_PIN จึงจะขัดจังหวะได้
     -
    //#กำหนด USE_UHS3_USB
  #สิ้นสุด

  -
   * เมื่อใช้ bootloader ที่รองรับ SD-Firmware-Flashing
   * เพิ่มรายการเมนูเพื่อเปิดใช้งาน SD-FW-Update ในการรีบูตครั้งถัดไป
   -
   * ต้องใช้ ATMEGA2560 (Arduino Mega)
   -
   * ทดสอบด้วย bootloader นี้:
   * https://github.com/FleetProbe/ไมโครบริดจ์-Arduino-ATMega2560
   -
  //#กำหนด SD_FIRMWARE_UPDATE
  #ถ้าเปิดใช้งาน (SD_FIRMWARE_UPDATE)
    #กำหนด SD_FIRMWARE_UPDATE_EEPROM_ADDR 0x1FF
    #กำหนดค่า SD_FIRMWARE_UPDATE_ACTIVE_VALUE 0xF0
    #กำหนดค่า SD_FIRMWARE_UPDATE_INACTIVE_VALUE 0xFF
  #สิ้นสุด

  // เพิ่มโหมดถ่ายโอนไฟล์ไบนารีที่ได้รับการปรับให้เหมาะสม เริ่มต้นด้วย 'M28 B1'
  //#กำหนด BINARY_FILE_TRANSFER

  -
   * ตั้งค่าตัวเลือกนี้เป็นหนึ่งในรายการต่อไปนี้ (หรือใช้ค่าเริ่มต้นของบอร์ด):
   -
   * LCD - ใช้ไดรฟ์ SD ในตัวควบคุม LCD ภายนอก
   * ONBOARD - ใช้ไดรฟ์ SD บนบอร์ดควบคุม (ไม่มี SD_DETECT_PIN M21 เพื่อเริ่มต้น)
   * CUSTOM_CABLE - ใช้สายเคเบิลที่กำหนดเองเพื่อเข้าถึง SD (ตามที่กำหนดไว้ในไฟล์พิน)
   -
   * :[ 'LCD', 'ออนบอร์ด', 'สายที่กำหนดเอง' ]
   -
  #define SDCARD_CONNECTION ออนบอร์ด

#endif // สนับสนุน SD

-
 * ตามค่าเริ่มต้น เครื่องอ่านการ์ด SD ออนบอร์ดอาจใช้ร่วมกันเป็น USB mass ได้
 * อุปกรณ์จัดเก็บข้อมูล ตัวเลือกนี้จะซ่อนการ์ด SD จากพีซีโฮสต์
 -
//#define NO_SD_HOST_DRIVE // ปิดการใช้งานการเข้าถึงการ์ด SD ผ่าน USB (เพื่อความปลอดภัย)

-
 * ตัวเลือกเพิ่มเติมสำหรับการแสดงผลแบบกราฟิก
 -
 * ใช้การเพิ่มประสิทธิภาพที่นี่เพื่อปรับปรุงประสิทธิภาพการพิมพ์
 * ซึ่งอาจได้รับผลกระทบเชิงลบจากการวาดภาพแสดงกราฟิก
 * โดยเฉพาะเมื่อทำการเคลื่อนไหวสั้นๆ หลายๆ ครั้ง และเมื่อพิมพ์
 * บนเครื่อง DELTA และ SCARA
 -
 * ตัวเลือกบางส่วนเหล่านี้อาจทำให้การแสดงผลล่าช้า
 * เหตุการณ์ตัวควบคุม เนื่องจากมีการแลกเปลี่ยนระหว่างความน่าเชื่อถือ
 * ประสิทธิภาพการพิมพ์เทียบกับการอัปเดตการแสดงผลอย่างรวดเร็ว
 -
#ถ้ามี HAS_MARLINUI_U8GLIB
  // แสดงเปอร์เซ็นต์ SD ถัดจากแถบความคืบหน้า
  //#กำหนด DOGM_SD_PERCENT

  // ประหยัดเวลาได้หลายรอบด้วยการวาดกรอบว่างหรือไม่มีกรอบบนหน้าจอข้อมูล
  //#กำหนด XYZ_NO_FRAME
  #กำหนด XYZ_HOLLOW_FRAME

  // เปิดใช้งานเพื่อบันทึกรอบจำนวนมากโดยการวาดกรอบว่างบนหน้าจอเมนู
  #กำหนด MENU_HOLLOW_FRAME

  มีแบบอักษรขนาดใหญ่กว่าสำหรับแก้ไขรายการ ค่าใช้จ่าย 3120 ไบต์ของ PROGMEM
  // เฉพาะภาษาตะวันตกเท่านั้น ไม่สามารถใช้ได้กับภาษาซีริลลิก คานะ ตุรกี กรีก หรือจีน
  //#กำหนด USE_BIG_EDIT_FONT

  อาจใช้แบบอักษรขนาดเล็กกว่าได้บนหน้าจอข้อมูล มีค่าใช้จ่าย 2,434 ไบต์สำหรับ PROGMEM
  // เฉพาะภาษาตะวันตกเท่านั้น ไม่สามารถใช้ได้กับภาษาซีริลลิก คานะ ตุรกี กรีก หรือจีน
  //#กำหนด USE_SMALL_INFOFONT

  // สลับตัวบ่งชี้ CW/CCW ในโอเวอร์เลย์กราฟิก
  //#กำหนด OVERLAY_GFX_REVERSE

  -
   * จอ LCD ที่ใช้ ST7920 สามารถจำลองการแสดงผล 16 x 4 อักขระได้โดยใช้
   * เครื่องสร้างตัวอักษร ST7920 สำหรับการอัปเดตหน้าจอที่รวดเร็วมาก
   * เปิดใช้งาน LIGHTWEIGHT_UI เพื่อใช้โหมดการแสดงผลพิเศษนี้
   -
   * เนื่องจาก LIGHTWEIGHT_UI มีพื้นที่จำกัด ตำแหน่งและสถานะ
   * ข้อความอยู่ในบรรทัดเดียวกัน ตั้งค่า STATUS_EXPIRE_SECONDS เป็น
   * ระยะเวลาที่จะแสดงข้อความสถานะก่อนทำการล้าง
   -
   * ตั้ง STATUS_EXPIRE_SECONDS เป็นศูนย์เพื่อไม่ให้ล้างสถานะเลย
   * การกระทำดังกล่าวจะป้องกันไม่ให้มีการแสดงการอัปเดตตำแหน่ง
   -
  #ถ้าเปิดใช้งาน (U8GLIB_ST7920)
    // เปิดใช้งานตัวเลือกนี้และลดค่าเพื่อเพิ่มประสิทธิภาพการอัปเดตหน้าจอ
    // ค่าดีเลย์ปกติคือ 10 วินาที ใช้ค่าต่ำสุดที่ยังแสดงผลได้น่าเชื่อถือ
    //#กำหนด DOGM_SPI_DELAY_US 5

    //#กำหนด LIGHTWEIGHT_UI
    #ถ้าเปิดใช้งาน (LIGHTWEIGHT_UI)
      #กำหนดสถานะ STATUS_EXPIRE_SECONDS 20
    #สิ้นสุด
  #สิ้นสุด

  -
   * การปรับแต่งหน้าจอสถานะ (ข้อมูล)
   * ตัวเลือกเหล่านี้อาจส่งผลต่อขนาดโค้ดและเวลาในการแสดงผลหน้าจอ
   * หน้าจอสถานะแบบกำหนดเองสามารถบังคับให้มีการแก้ไขการตั้งค่าเหล่านี้ได้
   -
  //#define STATUS_COMBINE_HEATERS // ใช้ภาพฮีตเตอร์แบบรวมแทนแบบแยกกัน
  //#define STATUS_HOTEND_NUMBERLESS // ใช้ไอคอนฮอทเอนด์ธรรมดาแทนไอคอนที่มีตัวเลข (โดยมีฮอทเอนด์ 2 ตัวขึ้นไป)
  #define STATUS_HOTEND_INVERTED // แสดงบิตแมปหัวฉีดแบบทึบเมื่อทำการให้ความร้อน (ต้องมี STATUS_HOTEND_ANIM)
  #define STATUS_HOTEND_ANIM // ใช้บิตแมปที่สองเพื่อระบุการให้ความร้อนของฮอทเอนด์
  #define STATUS_BED_ANIM // ใช้บิตแมปที่สองเพื่อระบุการให้ความร้อนบนเตียง
  #define STATUS_CHAMBER_ANIM // ใช้บิตแมปที่สองเพื่อระบุการให้ความร้อนในห้อง
  //#define STATUS_CUTTER_ANIM // ใช้บิตแมปที่สองเพื่อระบุสปินเดิล/เลเซอร์ที่ใช้งานอยู่
  //#define STATUS_ALT_BED_BITMAP // ใช้บิตแมปเตียงทางเลือก
  //#define STATUS_ALT_FAN_BITMAP // ใช้บิตแมปพัดลมทางเลือก
  //#define STATUS_FAN_FRAMES 3 // :[0,1,2,3,4] จำนวนเฟรมแอนิเมชั่นแฟน ๆ
  //#define STATUS_HEAT_PERCENT // แสดงความร้อนในแถบความคืบหน้า
  //#define BOOT_MARLIN_LOGO_SMALL // แสดงโลโก้ Marlin ขนาดเล็กบนหน้าจอบูต (ประหยัดแฟลช 399 ไบต์)
  //#define BOOT_MARLIN_LOGO_ANIMATED // โลโก้ Marlin แบบเคลื่อนไหว ต้นทุน ~โ€3260 (หรือ ~940) ไบต์ของ PROGMEM

  // ตัวเลือกเกมที่ไร้สาระ
  //#กำหนด MARLIN_BRICKOUT
  #กำหนด MARLIN_INVADERS
  //#กำหนด MARLIN_SNAKE
  #define GAMES_EASTER_EGG // เพิ่มบรรทัดว่างพิเศษเหนือเมนูย่อย "เกม"

#สิ้นสุดถ้า // HAS_MARLINUI_U8GLIB

-
// ตัวเลือกเพิ่มเติมสำหรับการแสดงผล DGUS / DWIN
-
#ถ้ามี HAS_DGUS_LCD
  #กำหนด LCD_SERIAL_PORT 3
  #กำหนด LCD_BAUDRATE 115200

  #กำหนด DGUS_RX_BUFFER_SIZE 128
  #กำหนด DGUS_TX_BUFFER_SIZE 48
  //#define SERIAL_STATS_RX_BUFFER_OVERRUNS // แก้ไขสถานการณ์ Rx overrun (ปัจจุบันสำหรับ AVR เท่านั้น)

  #define DGUS_UPDATE_INTERVAL_MS 500 // (ms) ช่วงเวลาระหว่างการอัปเดตหน้าจออัตโนมัติ

  #ถ้าอย่างใดอย่างหนึ่ง(DGUS_LCD_UI_FYSETC, DGUS_LCD_UI_HIPRECY)
    #define DGUS_PRINT_FILENAME // แสดงชื่อไฟล์ในระหว่างการพิมพ์
    #define DGUS_PREHEAT_UI // แสดงหน้าจออุ่นเครื่องระหว่างการอุ่นเครื่อง

    #ถ้าเปิดใช้งาน (DGUS_LCD_UI_FYSETC)
      //#define DGUS_UI_MOVE_DIS_OPTION // ปิดใช้งานตามค่าเริ่มต้นสำหรับ UI_FYSETC
    #อื่น
      #define DGUS_UI_MOVE_DIS_OPTION // เปิดใช้งานตามค่าเริ่มต้นสำหรับ UI_HIPRECY
    #สิ้นสุด

    #กำหนด DGUS_FILAMENT_LOADUNLOAD
    #ถ้าเปิดใช้งาน(DGUS_FILAMENT_LOADUNLOAD)
      #define DGUS_FILAMENT_PURGE_LENGTH 10
      #define DGUS_FILAMENT_LOAD_LENGTH_PER_TIME 0.5 // (มม.) ปรับตามสัดส่วนของ DGUS_UPDATE_INTERVAL_MS
    #สิ้นสุด

    #define DGUS_UI_WAITING // แสดงหน้าจอ "รอ" ระหว่างหน้าจอบางหน้าจอ
    #ถ้าเปิดใช้งาน (DGUS_UI_WAITING)
      #กำหนดสถานะ DGUS_UI_WAITING_STATUS 10
      #define DGUS_UI_WAITING_STATUS_PERIOD 8 // เพิ่มการวนซ้ำสถานะการรอให้ช้าลง
    #สิ้นสุด
  #สิ้นสุด
#endif // HAS_DGUS_LCD

-
// Touch UI สำหรับ FTDI Embedded Video Engine (EVE)
-
#ถ้าเปิดใช้งาน (TOUCH_UI_FTDI_EVE)
  // บอร์ดแสดงผลที่ใช้
  //#define LCD_FTDI_VM800B35A // FTDI 3.5" พร้อม FT800 (320x240)
  //#define LCD_4DSYSTEMS_4DLCD_FT843 // ระบบ 4D 4.3" (480x272)
  //#define LCD_HAOYU_FT800CB // Haoyu ขนาด 4.3" หรือ 5" (480x272)
  //#define LCD_HAOYU_FT810CB // Haoyu ขนาด 5" (800x480)
  //#define LCD_ALEPHOBJECTS_CLCD_UI // สีของ UI LCD ของวัตถุ Aleph
  //#define LCD_FYSETC_TFT81050 // FYSETC ขนาด 5" (800x480)

  // แก้ไขความละเอียดหากไม่ได้ใช้แผง TFT สต็อก
  //#กำหนด TOUCH_UI_320x240
  //#กำหนด TOUCH_UI_480x272
  //#กำหนด TOUCH_UI_800x480

  // การแมปสำหรับบอร์ดที่มีตัวเชื่อมต่อ RepRapDiscount Display มาตรฐาน
  //#define AO_EXP1_PINMAP // การแมป AlephObjects CLCD UI EXP1
  //#define AO_EXP2_PINMAP // การแมป AlephObjects CLCD UI EXP2
  //#define CR10_TFT_PINMAP // การแมปพิน CR10 ของ Rudolph Riedel
  //#define S6_TFT_PINMAP // การแมปพิน S6 ของ FYSETC
  //#define F6_TFT_PINMAP // FYSETC การแมปพิน F6

  //#define OTHER_PIN_LAYOUT // กำหนดพินด้วยตนเองด้านล่าง
  #ถ้าเปิดใช้งาน (OTHER_PIN_LAYOUT)
    // ต้องเลือกพินสำหรับ CS และ MOD_RESET (PD)
    #กำหนด CLCD_MOD_RESET 9
    #กำหนด CLCD_SPI_CS 10

    // หากใช้ซอฟต์แวร์ SPI ให้ระบุพินสำหรับ SCLK, MOSI, MISO
    //#กำหนด CLCD_USE_SOFT_SPI
    #ถ้าเปิดใช้งาน (CLCD_USE_SOFT_SPI)
      #กำหนด CLCD_SOFT_SPI_MOSI 11
      #กำหนด CLCD_SOFT_SPI_MISO 12
      #กำหนด CLCD_SOFT_SPI_SCLK 13
    #สิ้นสุด
  #สิ้นสุด

  // การวางแนวของจอภาพ จอภาพแบบกลับหัว
  // รองรับบน FT800 และ FT810 และรุ่นต่อๆ มาก็รองรับเช่นกัน
  // การวางแนวแบบแนวตั้งและแบบกระจก
  //#กำหนด TOUCH_UI_INVERTED
  //#กำหนด TOUCH_UI_PORTRAIT
  //#กำหนด TOUCH_UI_MIRRORED

  // การประมวลผลและการเรนเดอร์ UTF8
  // ตัวอักษรที่ไม่รองรับจะแสดงเป็น '?'
  //#กำหนด TOUCH_UI_USE_ UTF8
  #ถ้าเปิดใช้งาน (TOUCH_UI_USE_UTF8)
    // รองรับสำเนียงตะวันตก ตัวอักษรที่มีสำเนียงเหล่านี้ใช้
    // บิตแมปรวมกันและต้องการพื้นที่เก็บข้อมูลค่อนข้างน้อย
    #กำหนด TOUCH_UI_UTF8_WESTERN_CHARSET
    #ถ้าเปิดใช้งาน (TOUCH_UI_UTF8_WESTERN_CHARSET)
      // กลุ่มอักขระเพิ่มเติม อักขระเหล่านี้จำเป็นต้องมี
      // บิตแมปแบบเต็มและใช้พื้นที่เก็บข้อมูลมากพอสมควร:
      //#define TOUCH_UI_UTF8_SUPERSCRIPTS // ยนยฒยณ
      //#define TOUCH_UI_UTF8_COPYRIGHT // ยฉยฎ
      //#define TOUCH_UI_UTF8_GERMANIC // รั
      //#define TOUCH_UI_UTF8_SCANDINAVIAN // ร† ร ร˜ รž รฆ รฐ รพ
      //#define TOUCH_UI_UTF8_PUNCTUATION // ยซยปยฟยก
      //#define TOUCH_UI_UTF8_CURRENCY // ยขยชยคยฅ
      //#define TOUCH_UI_UTF8_ORDINALS // ยบยช
      //#define TOUCH_UI_UTF8_MATHEMATICS // ยฑ ร— รท
      //#define TOUCH_UI_UTF8_FRACTIONS // ยผยฝยพ
      //#define TOUCH_UI_UTF8_SYMBOLS // ยตยถยฆยงยฌ
    #สิ้นสุด
  #สิ้นสุด

  // ใช้แบบอักษรขนาดเล็กเมื่อป้ายไม่พอดีกับปุ่ม
  #กำหนดTOUCH_UI_FIT_TEXT

  // อนุญาตให้เลือกภาษาจากเมนูขณะรันไทม์ (มิฉะนั้นให้ใช้ LCD_LANGUAGE)
  //#define LCD_LANGUAGE_1 ใน
  //#กำหนด LCD_LANGUAGE_2
  //#define LCD_LANGUAGE_3 ของ
  //#กำหนด LCD_LANGUAGE_4
  //#define LCD_LANGUAGE_5 มัน

  // ใช้รหัสผ่านตัวเลขสำหรับแป้นกด "ล็อคหน้าจอ"
  // (แนะนำสำหรับจอแสดงผลขนาดเล็ก)
  //#กำหนด TOUCH_UI_PASSCODE

  // แสดงข้อมูลการดีบักเพิ่มเติมสำหรับเหตุการณ์ Touch UI
  //#กำหนด TOUCH_UI_DEBUG

  // เมนูสำหรับนักพัฒนา (เข้าถึงได้โดยแตะที่ข้อความลิขสิทธิ์ "เกี่ยวกับเครื่องพิมพ์")
  //#กำหนด TOUCH_UI_DEVELOPER_MENU
#สิ้นสุด

-
// FSMC / SPI กราฟิก TFT
-
#ถ้า TFT_SCALED_DOGLCD
  //#กำหนดกราฟิค_TFT_ROTATE_180
  //#define TFT_MARLINUI_COLOR 0xFFFF // สีขาว
  //#define TFT_MARLINBG_COLOR 0x0000 // ดำ
  //#define TFT_DISABLED_COLOR 0x0003 // เกือบดำ
  //#define TFT_BTCANCEL_COLOR 0xF800 // สีแดง
  //#define TFT_BTARROWS_COLOR 0xDEE6 // 11011 110111 00110 เหลือง
  //#define TFT_BTOKMENU_COLOR 0x145F // 00010 100010 11111 สีฟ้า
#สิ้นสุด

-
// ปุ่ม ADC ดีบาวน์
-
#ถ้ามี HAS_ADC_BUTTONS
  #define ADC_BUTTON_DEBOUNCE_DELAY 16 // เพิ่มถ้าปุ่มเด้งหรือทำซ้ำเร็วเกินไป
#สิ้นสุด

// @หมวดความปลอดภัย

-
 * ตัวจับเวลาฮาร์ดแวร์วอทช์ด็อกจะทำการรีเซ็ตและปิดการใช้งานเอาท์พุตทั้งหมด
 * หากเฟิร์มแวร์โอเวอร์โหลดเกินไปจนไม่สามารถอ่านเซ็นเซอร์อุณหภูมิได้
 -
 * หากคุณพบว่าการรีบูต watchdog ทำให้บอร์ด AVR ของคุณค้างถาวร
 * เปิดใช้งาน WATCHDOG_RESET_MANUAL เพื่อใช้ตัวจับเวลาที่กำหนดเองแทน WDTO
 * หมายเหตุ: วิธีนี้มีความน่าเชื่อถือต่ำ เนื่องจากสามารถตรวจจับการค้างได้เฉพาะในขณะที่
 * เปิดใช้งานการขัดจังหวะแล้ว
 -
#กำหนดใช้_WATCHDOG
#ถ้าเปิดใช้งาน (USE_WATCHDOG)
  //#กำหนด WATCHDOG_RESET_MANUAL
#สิ้นสุด

// @ส่วนจอ LCD

-
 * Babystepping ช่วยให้สามารถเคลื่อนที่แกนได้ทีละน้อยโดยไม่ต้องเปลี่ยนแปลง
 * ค่าตำแหน่งปัจจุบัน ฟีเจอร์นี้ใช้เพื่อปรับค่า Z เป็นหลัก
 * แกนในชั้นแรกของการพิมพ์แบบเรียลไทม์
 -
 * คำเตือน: ไม่เคารพค่าหยุด!
 -
#กำหนดนิยามการก้าวเดินแบบเด็ก
#ถ้าเปิดใช้งาน (การเลี้ยงลูกเอง)
  //#define INTEGRATED_BABYSTEPPING // การบูรณาการแบบทดลองของ babystepping เข้ากับ Stepper ISR
  //#กำหนด BABYSTEP_WITHOUT_HOMING
  //#define BABYSTEP_ALWAYS_AVAILABLE // อนุญาตให้ค่อยๆ ก้าวเดินทีละก้าวตลอดเวลา (ไม่ใช่แค่ระหว่างการเคลื่อนไหว)
  //#define BABYSTEP_XY // เปิดใช้งาน X/Y Babystepping ด้วย ไม่รองรับใน DELTA!
  #define BABYSTEP_INVERT_Z false // เปลี่ยนว่า Z ควรก้าวไปในทางอื่นหรือไม่
  //#define BABYSTEP_MILLIMETER_UNITS // ระบุ BABYSTEP_MULTIPLICATOR_(XY|Z) เป็นมิลลิเมตรแทนไมโครสเต็ป
  #define BABYSTEP_MULTIPLICATOR_Z 1 // (ก้าวหรือมิลลิเมตร) ระยะก้าวหรือมิลลิเมตรสำหรับก้าวแรกแต่ละ Z
  #define BABYSTEP_MULTIPLICATOR_XY 1 // (ก้าวหรือมิลลิเมตร) ระยะก้าวหรือมิลลิเมตรสำหรับก้าวแรก XY แต่ละก้าว

  #define DOUBLECLICK_FOR_Z_BABYSTEPPING // คลิกสองครั้งบนหน้าจอสถานะสำหรับ Z Babystepping
  #ถ้าเปิดใช้งาน (คลิกสองครั้งเพื่อ Z_BABYSTEPPING)
    #define DOUBLECLICK_MAX_INTERVAL 1250 // ช่วงเวลาสูงสุดระหว่างการคลิก เป็นมิลลิวินาที
                                            // หมายเหตุ: อาจเพิ่มเวลาพิเศษเพื่อลดความล่าช้าของตัวควบคุม
    //#define MOVE_Z_WHEN_IDLE // ข้ามไปที่เมนูย้าย Z โดยการดับเบิลคลิกเมื่อเครื่องพิมพ์ไม่ได้ใช้งาน
    #ถ้าเปิดใช้งาน (MOVE_Z_WHEN_IDLE)
      #define MOVE_Z_IDLE_MULTIPLICATOR 1 // คูณ 1 มม. ด้วยปัจจัยนี้สำหรับขนาดขั้นตอนการเคลื่อนย้าย
    #สิ้นสุด
  #สิ้นสุด

  //#define BABYSTEP_DISPLAY_TOTAL // แสดงจำนวนก้าวแรกทั้งหมดตั้งแต่ G28 ครั้งล่าสุด

  #define BABYSTEP_ZPROBE_OFFSET // รวม M851 Z และ Babystepping
  #ถ้าเปิดใช้งาน (BABYSTEP_ZPROBE_OFFSET)
    //#define BABYSTEP_HOTEND_Z_OFFSET // สำหรับฮอทเอนด์หลายตัว ออฟเซ็ต Z สัมพันธ์แบบเบบี้สเต็ป
    #define BABYSTEP_ZPROBE_GFX_OVERLAY // เปิดใช้งานการซ้อนทับกราฟิกบนตัวแก้ไข Z-offset
  #สิ้นสุด
#สิ้นสุด

// @section เครื่องอัดรีด

-
 * การควบคุมแรงดันเชิงเส้น v1.5
 -
 * สมมติฐาน: ล่วงหน้า [ก้าว] = k * (ความเร็วเดลต้า [ก้าว/วินาที])
 * K=0 หมายถึงปิดใช้งานล่วงหน้า
 -
 * หมายเหตุ: ค่า K สำหรับ LIN_ADVANCE 1.5 แตกต่างจากเวอร์ชันก่อนหน้านี้!
 -
 * ตั้งค่า K ประมาณ 0.22 สำหรับ PLA Direct Drive 3 มม. โดยเว้นระยะห่างระหว่างเฟืองขับเคลื่อนและตัวตัดความร้อนประมาณ 6.5 ซม.
 * ต้องใช้ค่า K ที่มากขึ้นสำหรับเส้นใยที่มีความยืดหยุ่นและระยะทางที่มากขึ้น
 * หากอัลกอริธึมนี้สร้างออฟเซ็ตความเร็วที่สูงกว่าที่เครื่องอัดรีดจะรับมือได้ (เมื่อเปรียบเทียบกับ E Jerk)
 * การเร่งความเร็วในการพิมพ์จะลดลงระหว่างการเคลื่อนตัวที่ได้รับผลกระทบเพื่อให้คงอยู่ในขีดจำกัด
 -
 * ดู https://marlinfw.org/docs/features/lin_advance.html เพื่อดูคำแนะนำฉบับเต็ม
 -
#กำหนด LIN_ADVANCE
#ถ้าเปิดใช้งาน (LIN_ADVANCE)
  //#define EXTRA_LIN_ADVANCE_K // เปิดใช้งานสำหรับค่าคงที่การเลื่อนเชิงเส้นที่สอง
  #define LIN_ADVANCE_K 0.0 // หน่วย: มม. การบีบอัดต่อความเร็วเครื่องอัด 1 มม./วินาที
  //#define LA_DEBUG // หากเปิดใช้งาน จะสร้างเอาท์พุตข้อมูลการดีบักผ่าน USB
  #define EXPERIMENTAL_SCURVE // เปิดใช้งานตัวเลือกนี้เพื่ออนุญาตให้เร่งความเร็ว S-Curve
#สิ้นสุด

// @การปรับระดับส่วน

-
 * จุดที่ต้องตรวจสอบสำหรับขั้นตอนการปรับระดับ 3 จุดทั้งหมด
 * แทนที่ถ้าจุดที่เลือกโดยอัตโนมัติไม่เพียงพอ
 -
#ถ้า EITHER(AUTO_BED_LEVELING_3POINT, AUTO_BED_LEVELING_UBL)
  //#กำหนด PROBE_PT_1_X 15
  //#กำหนด PROBE_PT_1_Y 180
  //#กำหนด PROBE_PT_2_X 15
  //#กำหนด PROBE_PT_2_Y 20
  //#กำหนด PROBE_PT_3_X 170
  //#กำหนด PROBE_PT_3_Y 20
#สิ้นสุด

-
 * การตรวจสอบระยะขอบ
 -
 * การแทนที่ PROBING_MARGIN สำหรับแต่ละด้านของแผ่นสร้าง
 * มีประโยชน์ในการรับจุดตรวจสอบไปยังตำแหน่งที่แน่นอนบนเป้าหมายหรือ
 * เพื่อให้สามารถปรับระดับได้เพื่อหลีกเลี่ยงการหนีบแผ่นเฉพาะจุด
 * ด้านข้างของเตียง โดยมีค่า NOZZLE_AS_PROBE เป็นค่าลบ
 * อนุญาตให้เข้าไปสอดส่องนอกเตียงได้
 -
 * หากคุณกำลังแทนที่ตัวเลือก *_PROBE_BED_POSITION ก่อนหน้า
 * ค่า LEFT และ FRONT ในกรณีส่วนใหญ่จะแมปโดยตรงบน
 * ขวาและด้านหลังจะเป็นแบบผกผันกัน เช่น
 * (X/Y_BED_SIZE - ขวา/BACK_PROBE_BED_POSITION)
 -
 * วิธีนี้จะทำให้ตำแหน่งทั้งหมดตรงกันในการคอมไพล์อย่างไรก็ตาม
 * หากตำแหน่งหัววัดควรปรับเปลี่ยนด้วย M851XY แล้ว
 * จุดตรวจสอบจะตามมา ซึ่งจะป้องกันไม่ให้เกิดการเปลี่ยนแปลงใดๆ
 * หัววัดไม่สามารถไปถึงจุดใดเลย
 -
#ถ้า PROBE_SELECTED และ !IS_KINEMATIC
  //#กำหนด PROBING_MARGIN_LEFT PROBING_MARGIN
  //#กำหนด PROBING_MARGIN_RIGHT PROBING_MARGIN
  //#กำหนด PROBING_MARGIN_FRONT PROBING_MARGIN
  //#กำหนด PROBING_MARGIN_BACK PROBING_MARGIN
#สิ้นสุด

#ถ้า EITHER(MESH_BED_LEVELING, AUTO_BED_LEVELING_UBL)
  // ยกเลิกพื้นที่ตาข่ายถ้าพื้นที่อัตโนมัติ (สูงสุด) มีขนาดใหญ่เกินไป
  //#กำหนดMESH_MIN_X MESH_INSET
  //#กำหนดMESH_MIN_Y MESH_INSET
  //#กำหนดMESH_MAX_X X_BED_SIZE - (MESH_INSET)
  //#กำหนดขนาด MESH_MAX_Y Y_BED_SIZE - (MESH_INSET)
#สิ้นสุด

-
 * พยายามปรับระดับ G29 ซ้ำๆ จนกว่าจะสำเร็จ
 * หยุดหลังจากพยายาม G29_MAX_RETRIES ครั้ง
 -
//#กำหนด G29_RETRY_AND_RECOVER
#ถ้าเปิดใช้งาน (G29_RETRY_AND_RECOVER)
  #กำหนด G29_MAX_RETRIES 3
  #กำหนด G29_HALT_ON_FAILURE
  -
   * ระบุคำสั่ง GCODE ที่จะดำเนินการเมื่อการเลเวลสำเร็จ
   * ระหว่างความพยายาม และหลังจากที่ได้ลองทำซ้ำครบจำนวนสูงสุดแล้ว
   -
  #define G29_SUCCESS_COMMANDS "การปรับระดับเตียง M117 เสร็จเรียบร้อยแล้ว"
  #define G29_RECOVER_COMMANDS "โพรบ M117 ล้มเหลว กำลังทำการล้างข้อมูลใหม่\nG28\nG12 P0 S12 T0"
  #define G29_FAILURE_COMMANDS "M117 การปรับระดับเตียงล้มเหลว\nG0 Z10\nM300 P25 ​​S880\nM300 P50 S0\nM300 P25 ​​S880\nM300 P50 S0\nM300 P25 ​​S880\nM300 P50 S0\nG4 S1"

#สิ้นสุด

-
 * การชดเชยอุณหภูมิของโพรบ
 * การวัดหัววัดได้รับการปรับเพื่อชดเชยการบิดเบือนของอุณหภูมิ
 * ใช้ G76 เพื่อปรับเทียบคุณสมบัตินี้ ใช้ M871 เพื่อตั้งค่าด้วยตนเอง
 * สำหรับคำอธิบายโดยละเอียดเพิ่มเติมของกระบวนการ โปรดดู G76_M871.cpp
 -
#ถ้า HAS_BED_PROBE และ TEMP_SENSOR_PROBE และ TEMP_SENSOR_BED
  // เปิดใช้งานการชดเชยชั้นความร้อนแรกโดยใช้อุณหภูมิของเตียงและหัววัด
  #กำหนดค่า PROBE_TEMP_COMPENSATION

  // เพิ่มค่าชดเชยเพิ่มเติมตามอุณหภูมิฮอทเอนด์
  // หมายเหตุ: ค่าเหล่านี้ไม่สามารถปรับเทียบได้และต้องตั้งค่าด้วยตนเอง
  #ถ้าเปิดใช้งาน (PROBE_TEMP_COMPENSATION)
    // ตำแหน่งจอดเพื่อรอให้หัววัดเย็นลง
    #กำหนด PTC_PARK_POS { 0, 0, 100 }

    // ตำแหน่งหัววัดที่จะวัดและรอให้หัววัดถึงอุณหภูมิเป้าหมาย
    #กำหนด PTC_PROBE_POS { 90, 100 }

    // เปิดใช้งานการชดเชยเพิ่มเติมโดยใช้อุณหภูมิฮอทเอนด์
    // หมายเหตุ: ค่าเหล่านี้ไม่สามารถปรับเทียบอัตโนมัติได้ แต่จะต้องตั้งค่าด้วยตนเอง
    //#กำหนด USE_TEMP_EXT_COMPENSATION

    // การสอบเทียบอุณหภูมิของหัววัดจะสร้างตารางค่าเริ่มต้นที่ PTC_SAMPLE_START
    // (เช่น 30) ในขั้นตอนของ PTC_SAMPLE_RES (เช่น 5) พร้อมด้วยตัวอย่าง PTC_SAMPLE_COUNT (เช่น 10)

    //#กำหนด PTC_SAMPLE_START 30.0f
    //#กำหนด PTC_SAMPLE_RES 5.0f
    //#กำหนด PTC_SAMPLE_COUNT 10U

    // การสอบเทียบอุณหภูมิเตียงสร้างตารางที่คล้ายกัน

    //#กำหนด BTC_SAMPLE_START 60.0f
    //#กำหนด BTC_SAMPLE_RES 5.0f
    //#กำหนด BTC_SAMPLE_COUNT 10U

    // อุณหภูมิที่หัววัดควรอยู่ที่ขณะทำการวัดขณะอุณหภูมิเตียง
    // การสอบเทียบ
    //#กำหนด BTC_PROBE_TEMP 30.0f

    // ความสูงเหนือ Z=0.0f เพื่อยกหัวฉีดขึ้น การลดความสูงลงจะช่วยให้หัววัดร้อนเร็วขึ้น
    หมายเหตุ: ค่าออฟเซ็ต Z=0.0f จะถูกกำหนดโดยค่าออฟเซ็ตโพรบ ซึ่งสามารถตั้งค่าได้โดยใช้ M851
    //#กำหนดค่า PTC_PROBE_HEATING_OFFSET เป็น 0.5f

    // ความสูงในการยกหัววัด Z ระหว่างการให้ความร้อนและการวัดครั้งต่อไป หัววัดบางตัว
    // อาจไม่สามารถยกเลิกการทริกเกอร์ได้ หากถูกทริกเกอร์เป็นเวลานาน ซึ่งสามารถแก้ไขได้โดย
    // เพิ่มความสูงที่หัววัดยกขึ้น
    //#กำหนด PTC_PROBE_RAISE 15U

    // หากโพรบอยู่นอกช่วงที่กำหนด ให้ใช้การประมาณเชิงเส้นโดยใช้ค่าที่ใกล้เคียงที่สุด
    // จุดและจุดถัดไปของ PTC_LINEAR_EXTRAPOLATION เช่น ถ้าตั้งเป็น 4 จะใช้ data[0]
    // และข้อมูล[4] เพื่อดำเนินการประมาณค่าเชิงเส้นสำหรับค่าที่ต่ำกว่า PTC_SAMPLE_START
    //#กำหนด PTC_LINEAR_EXTRAPOLATION 4
  #สิ้นสุด
#สิ้นสุด

// @ส่วนเสริม

-
// บันทึกตำแหน่ง G60/G61 และกลับคืน
-
//#define SAVED_POSITIONS 1 // ช่องตำแหน่งที่บันทึกแต่ละช่องจะมีราคา 12 ไบต์

-
// รองรับอาร์ค G2/G3
-
#define ARC_SUPPORT // ปิดใช้งานฟีเจอร์นี้เพื่อบันทึก ~3226 ไบต์
#ถ้าเปิดใช้งาน (ARC_SUPPORT)
  #define MM_PER_ARC_SEGMENT 1 // (มม.) ความยาว (หรือความยาวขั้นต่ำ) ของส่วนโค้งแต่ละส่วน
  //#define ARC_SEGMENTS_PER_R 1 // ความยาวส่วนสูงสุด MM_PER = ต่ำสุด
  #define MIN_ARC_SEGMENTS 24 // จำนวนส่วนน้อยที่สุดในวงกลมที่สมบูรณ์
  //#define ARC_SEGMENTS_PER_SEC 50 // ใช้ฟีดเรตเพื่อเลือกความยาวเซกเมนต์ (โดยใช้ MM_PER_ARC_SEGMENT เป็นค่าต่ำสุด)
  #define N_ARC_CORRECTION 25 // จำนวนเซกเมนต์ที่สอดแทรกระหว่างการแก้ไข
  //#define ARC_P_CIRCLES // เปิดใช้งานพารามิเตอร์ 'P' เพื่อระบุวงกลมที่สมบูรณ์
  //#define CNC_WORKSPACE_PLANES // อนุญาตให้ G2/G3 ทำงานในระนาบ XY, ZX หรือ YZ
  //#define SF_ARC_FIX // เปิดใช้งานเฉพาะเมื่อใช้ SkeinForge กับขั้นตอนการทำฟิลเล็ต "Arc Point"
#สิ้นสุด

// รองรับ G5 ที่มีปลายทาง XYZE และออฟเซ็ต IJPQ ต้องใช้ ~2666 ไบต์
//#กำหนด BEZIER_CURVE_SUPPORT

-
 * ก้าวตรง
 -
 * เทียบได้กับวิธีที่ Klipper ใช้ G6 ก้าวตรงอย่างมีนัยสำคัญ
 * ลดการคำนวณการเคลื่อนไหว เพิ่มความเร็วในการพิมพ์สูงสุด และผลลัพธ์
 * ลดขั้นตอนการสร้างนามแฝงโดยการคำนวณการเคลื่อนไหวทั้งหมดล่วงหน้า
 * เตรียม G-code ของคุณ: https://github.com/colinrgodsey/step-daemon
 -
//#กำหนด DIRECT_STEPPING

-
 * เป้าหมายการตรวจสอบ G38
 -
 * ตัวเลือกนี้จะเพิ่ม G38.2 และ G38.3 (ตรวจสอบไปทางเป้าหมาย)
 * และ G38.4 และ G38.5 (เลือกได้) (โพรบห่างจากเป้าหมาย)
 * ตั้งค่า MULTIPLE_PROBING ให้ G38 ตรวจสอบมากกว่าหนึ่งครั้ง
 -
//#กำหนด G38_PROBE_TARGET
#ถ้าเปิดใช้งาน (G38_PROBE_TARGET)
  //#define G38_PROBE_AWAY // รวม G38.4 และ G38.5 เพื่อตรวจสอบห่างจากเป้าหมาย
  #define G38_MINIMUM_MOVE 0.0275 // (มม.) ระยะทางขั้นต่ำที่จะทำให้เกิดการเคลื่อนที่
#สิ้นสุด

// การเคลื่อนที่ (หรือส่วนต่างๆ) ที่มีขั้นตอนน้อยกว่านี้จะถูกรวมกับการเคลื่อนที่ครั้งต่อไป
#กำหนด MIN_STEPS_PER_SEGMENT 6

-
 * ความล่าช้าขั้นต่ำก่อนและหลังการตั้งค่าสเต็ปเปอร์ DIR (เป็น ns)
 * 0 : ไม่มีความล่าช้า (คาดหวังอย่างน้อย 10 วินาที เนื่องจาก Stepper ISR หนึ่งตัวจะต้องเกิดขึ้น)
 * 20 : ขั้นต่ำสำหรับไดรเวอร์ TMC2xxx
 * 200 : ขั้นต่ำสำหรับผู้ขับขี่ A4988
 * 400 : ขั้นต่ำสำหรับผู้ขับขี่ A5984
 * 500 : ขั้นต่ำสำหรับไดร์เวอร์ LV8729 (เดา ไม่มีข้อมูลในแผ่นข้อมูล)
 * 650 : ขั้นต่ำสำหรับไดรเวอร์ DRV8825
 * 1500 : ขั้นต่ำสำหรับไดร์เวอร์ TB6600 (เดา ไม่มีข้อมูลในแผ่นข้อมูล)
 * 15000: ขั้นต่ำสำหรับไดร์เวอร์ TB6560 (เดา ไม่มีข้อมูลในแผ่นข้อมูล)
 -
 * การแทนที่ค่าเริ่มต้นตามประเภทไดรเวอร์ที่ตั้งไว้ใน Configuration.h
 -
//#กำหนดระยะเวลา MINIMUM_STEPPER_POST_DIR_DELAY 650
//#กำหนดระยะเวลาขั้นต่ำ MINIMUM_STEPPER_PRE_DIR_DELAY 650

-
 * ความกว้างพัลส์ของไดรเวอร์สเต็ปเปอร์ขั้นต่ำ (หน่วย ยต.)
 * 0 : ความกว้างที่เล็กที่สุดที่ MCU สามารถผลิตได้ เข้ากันได้กับไดรเวอร์ TMC2xxx
 * 0 : ขั้นต่ำ 500ns สำหรับ LV8729 ปรับใน stepper.h
 * 1 : ขั้นต่ำสำหรับไดร์เวอร์สเต็ปเปอร์ A4988 และ A5984
 * 2 : ขั้นต่ำสำหรับไดรเวอร์สเต็ปเปอร์ DRV8825
 * 3 : ขั้นต่ำสำหรับไดร์เวอร์สเต็ปเปอร์ TB6600
 * 30 : ขั้นต่ำสำหรับไดร์เวอร์สเต็ปเปอร์ TB6560
 -
 * การแทนที่ค่าเริ่มต้นตามประเภทไดรเวอร์ที่ตั้งไว้ใน Configuration.h
 -
//#กำหนด MINIMUM_STEPPER_PULSE 2

-
 * อัตราการก้าวสูงสุด (ในหน่วยเฮิรตซ์) ที่ไดรเวอร์สเต็ปเปอร์อนุญาต
 * หากไม่ได้กำหนด ค่าเริ่มต้นคือ 1MHz / (2 * MINIMUM_STEPPER_PULSE)
 * 5000000 : สูงสุดสำหรับไดร์เวอร์สเต็ปเปอร์ TMC2xxx
 * 1000000 : สูงสุดสำหรับไดร์เวอร์สเต็ปเปอร์ LV8729
 * 500000 : สูงสุดสำหรับไดร์เวอร์สเต็ปเปอร์ A4988
 * 250000 : สูงสุดสำหรับไดร์เวอร์สเต็ปเปอร์ DRV8825
 * 150000 : สูงสุดสำหรับไดร์เวอร์สเต็ปเปอร์ TB6600
 * 15000 : สูงสุดสำหรับไดร์เวอร์สเต็ปเปอร์ TB6560
 -
 * การแทนที่ค่าเริ่มต้นตามประเภทไดรเวอร์ที่ตั้งไว้ใน Configuration.h
 -
//#กำหนดอัตรา MAXIMUM_STEPPER_RATE 250000

// @อุณหภูมิส่วน

// ควบคุมฮีตเตอร์ 0 และฮีตเตอร์ 1 ในแบบคู่ขนาน
//#กำหนด HEATERS_PARALLEL

-
//=================================== บัฟเฟอร์ =====================================
-

// @การเคลื่อนไหวส่วน

// จำนวนของการเคลื่อนที่เชิงเส้นที่สามารถทำได้ในเครื่องมือวางแผนในครั้งเดียว
// ค่าของ BLOCK_BUFFER_SIZE จะต้องเป็นเลขยกกำลัง 2 (เช่น 8, 16, 32)
#ถ้า BOTH(SDSUPPORT, DIRECT_STEPPING)
  #กำหนด BLOCK_BUFFER_SIZE 8
#elif เปิดใช้งานแล้ว (SDSUPPORT)
  #กำหนด BLOCK_BUFFER_SIZE 16
#อื่น
  #กำหนด BLOCK_BUFFER_SIZE 16
#สิ้นสุด

// @section ซีเรียล

// บัฟเฟอร์ ASCII สำหรับอินพุตแบบอนุกรม
#กำหนดขนาด MAX_CMD_SIZE 96
#กำหนด BUFSIZE 4

// ขนาดบัฟเฟอร์ในการส่งไปยังโฮสต์
// เพื่อบันทึก PROGMEM ขนาด 386 ไบต์ (และ TX_BUFFER_SIZE+3 ไบต์ของ RAM) ให้ตั้งค่าเป็น 0
// หากต้องการบัฟเฟอร์ "โอเค" แบบง่ายๆ คุณต้องใช้ 4 ไบต์
// สำหรับ ADVANCED_OK (M105) คุณต้องใช้ 32 ไบต์
// สำหรับ debug-echo: 128 ไบต์เพื่อความเร็วที่เหมาะสมที่สุด
// เอาท์พุตอื่น ๆ ไม่จำเป็นต้องรวดเร็วขนาดนั้น
:[0, 2, 4, 8, 16, 32, 64, 128, 256]
#กำหนด TX_BUFFER_SIZE 0

// ขนาดบัฟเฟอร์รับโฮสต์
// หากไม่มีการควบคุมการไหล XON/XOFF (ดู SERIAL_XON_XOFF ด้านล่าง) 32 ไบต์น่าจะเพียงพอ
// หากต้องการใช้การควบคุมการไหล ให้ตั้งค่าขนาดบัฟเฟอร์นี้เป็นอย่างน้อย 1,024 ไบต์
:[0, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048]
//#กำหนด RX_BUFFER_SIZE 1024

#ถ้า RX_BUFFER_SIZE >= 1024
  // เปิดใช้งานเพื่อให้ตัวควบคุมส่งอักขระควบคุม XON/XOFF ไปยัง
  // โฮสต์ที่จะส่งสัญญาณว่าบัฟเฟอร์ RX กำลังเต็ม
  //#กำหนด SERIAL_XON_XOFF
#สิ้นสุด

// เพิ่ม G-code M575 เพื่อเปลี่ยนอัตราบอดเรท
//#กำหนดอัตรา BAUD_RATE_GCODE

#ถ้าเปิดใช้งาน (SDSUPPORT)
  // เปิดใช้งานตัวเลือกนี้เพื่อรวบรวมและแสดงค่าสูงสุด
  // การใช้คิว RX หลังจากการถ่ายโอนไฟล์ไปยัง SD
  //#กำหนด SERIAL_STATS_MAX_RX_QUEUED

  // เปิดตัวเลือกนี้เพื่อรวบรวมและแสดงจำนวน
  // ของไบต์ที่ทิ้งหลังจากการถ่ายโอนไฟล์ไปยัง SD
  //#กำหนด SERIAL_STATS_DROPPED_RX
#สิ้นสุด

-
 * ตัววิเคราะห์คำสั่งฉุกเฉิน
 -
 * เพิ่มตัววิเคราะห์ระดับต่ำเพื่อสกัดกั้นคำสั่งบางคำสั่งในขณะที่
 * เข้าสู่บัฟเฟอร์รับข้อมูลแบบอนุกรม เพื่อไม่ให้ถูกบล็อคได้
 * ปัจจุบันรองรับ M108, M112, M410, M876
 *หมายเหตุ: ยังไม่ได้นำไปใช้กับทุกแพลตฟอร์ม
 -
#กำหนด EMERGENCY_PARSER

// การเชื่อมต่อแบบอนุกรมที่ไม่ดีอาจพลาดคำสั่งที่ได้รับโดยการส่ง 'ตกลง'
// ดังนั้นไคลเอนต์บางรายจึงยกเลิกหลังจากหมดเวลา 30 วินาที
// ไคลเอนต์รายอื่นบางรายเริ่มส่งคำสั่งในขณะที่ได้รับ 'รอ'
// "การรอ" นี้จะถูกส่งเมื่อบัฟเฟอร์ว่างเท่านั้น 1 วินาทีถือเป็นค่าที่ดีในกรณีนี้
//#define NO_TIMEOUTS 1000 // มิลลิวินาที

// ไคลเอนต์บางรายจะมีฟีเจอร์นี้ในเร็วๆ นี้ ซึ่งอาจทำให้ NO_TIMEOUTS ไม่จำเป็นอีกต่อไป
//#กำหนด ADVANCED_OK

// Printrun อาจประสบปัญหาในการรับสตริงยาวๆ ทั้งหมดในครั้งเดียว
// ตัวเลือกนี้จะแทรกเวลาหน่วงสั้นๆ ระหว่างบรรทัดของเอาต์พุตแบบอนุกรม
#กำหนด SERIAL_OVERRUN_PROTECTION

// สำหรับ serial echo จำนวนหลักหลังจุดทศนิยม
//#กำหนด SERIAL_FLOAT_PRECISION 4

// @ส่วนเสริม

-
 * ความเร็วพัดลมพิเศษ
 * เพิ่มความเร็วพัดลมรองให้กับพัดลมระบายความร้อนในการพิมพ์แต่ละตัว
 * 'M106 P<fan> T3-255' : ตั้งค่าความเร็วรองสำหรับ <fan>
 * 'M106 P<fan> T2' : ใช้ความเร็วรองที่ตั้งไว้
 * 'M106 P<fan> T1' : คืนค่าความเร็วพัดลมก่อนหน้า
 -
//#กำหนดความเร็วพัดลมพิเศษ

-
 * การควบคุมแบบเฟิร์มแวร์และ LCD
 -
 * เพิ่มคำสั่ง G10 / G11 สำหรับการถอน/กู้คืนตามเฟิร์มแวร์อัตโนมัติ
 * ใช้ M207 และ M208 ในการกำหนดพารามิเตอร์สำหรับการถอยกลับ / กู้คืน
 -
 * ใช้ M209 เพื่อเปิดหรือปิดการดึงกลับอัตโนมัติ
 * เมื่อเปิดใช้งานการหดกลับอัตโนมัติ G1 E ทั้งหมดจะเคลื่อนที่ภายในช่วงที่กำหนด
 * จะถูกแปลงเป็นการเคลื่อนไหวถอย/กู้คืนตามเฟิร์มแวร์
 -
 * อย่าลืมปิดการดึงกลับอัตโนมัติในระหว่างการเปลี่ยนเส้นใย
 -
 * โปรดทราบว่าการตั้งค่า M207 / M208 / M209 จะถูกบันทึกไว้ใน EEPROM
 -
//#กำหนด FWRETRACT
#ถ้าเปิดใช้งาน (FWRETRACT)
  #define FWRETRACT_AUTORETRACT // แทนที่การย้อนกลับของเครื่องตัด
  #ถ้าเปิดใช้งาน (FWRETRACT_AUTORETRACT)
    #define MIN_AUTORETRACT 0.1 // (mm) อย่าแปลงการเคลื่อนที่ E ที่มีความยาวน้อยกว่านี้
    #define MAX_AUTORETRACT 10.0 // (mm) อย่าแปลงการเคลื่อนที่ E เกินความยาวนี้
  #สิ้นสุด
  #define RETRACT_LENGTH 3 // (มม.) ความยาวการหดกลับเริ่มต้น (ค่าบวก)
  #define RETRACT_LENGTH_SWAP 13 // (มม.) ความยาวการสลับย้อนกลับเริ่มต้น (ค่าบวก)
  #define RETRACT_FEEDRATE 45 // (มม./วินาที) อัตราป้อนเริ่มต้นสำหรับการหดกลับ
  #define RETRACT_ZRAISE 0 // (มม.) การหดกลับแบบเริ่มต้น ยกแบบ Z
  #define RETRACT_RECOVER_LENGTH 0 // (มม.) ความยาวคืนตัวเพิ่มเติมเริ่มต้น (เพิ่มให้กับความยาวคืนตัวเมื่อคืนตัว)
  #define RETRACT_RECOVER_LENGTH_SWAP 0 // (มม.) ความยาวการกู้คืนสลับเพิ่มเติมเริ่มต้น (เพิ่มให้กับความยาวการหดกลับเมื่อกู้คืนจากการเปลี่ยนเครื่องมือ)
  #define RETRACT_RECOVER_FEEDRATE 8 // (มม./วินาที) อัตราป้อนเริ่มต้นสำหรับการฟื้นตัวจากการหดตัว
  #define RETRACT_RECOVER_FEEDRATE_SWAP 8 // (มม./วินาที) อัตราฟีดเริ่มต้นสำหรับการกู้คืนจากการหดตัวสลับ
  #ถ้าเปิดใช้งาน (MIXING_EXTRUDER)
    //#define RETRACT_SYNC_MIXING // ย้อนกลับและคืนค่าสเต็ปเปอร์การผสมทั้งหมดพร้อมกัน
  #สิ้นสุด
#สิ้นสุด

-
 * การตั้งค่าการเปลี่ยนเครื่องมือสากล
 * ใช้ได้กับเครื่องอัดรีดทุกประเภท ยกเว้นที่มีการระบุไว้ชัดเจน
 -
#ถ้ามี HAS_MULTI_EXTRUDER
  // ยกระยะห่าง Z เพื่อเปลี่ยนเครื่องมือ ตามที่จำเป็นสำหรับเครื่องอัดรีดบางรุ่น
  #define TOOLCHANGE_ZRAISE 2 // (มม.)
  //#define TOOLCHANGE_ZRAISE_BEFORE_RETRACT // ใช้การเพิ่มขึ้นก่อนการสลับกลับ (ถ้าเปิดใช้งาน)
  //#define TOOLCHANGE_NO_RETURN // อย่ากลับไปยังตำแหน่งก่อนหน้าเมื่อเปลี่ยนเครื่องมือ
  #ถ้าเปิดใช้งาน (TOOLCHANGE_NO_RETURN)
    //#define EVENT_GCODE_AFTER_TOOLCHANGE "G12X" // G-code พิเศษที่จะทำงานหลังจากเปลี่ยนเครื่องมือ
  #สิ้นสุด

  -
   * ดึงกลับและเตรียมเส้นใยเมื่อเปลี่ยนเครื่องมือเพื่อลด
   * ไหลซึมและร้อยเป็นเส้นเพื่อให้เกิดการเปลี่ยนผ่านที่สะอาดยิ่งขึ้น
   -
  //#กำหนด TOOLCHANGE_FILAMENT_SWAP
  #ถ้าเปิดใช้งาน (TOOLCHANGE_FILAMENT_SWAP)
    // โหลด / ขนถ่าย
    #define TOOLCHANGE_FS_LENGTH 12 // (มม.) ความยาวโหลด/ขนถ่าย
    #define TOOLCHANGE_FS_EXTRA_RESUME_LENGTH 0 // (มม.) ความยาวพิเศษเพื่อการรีสตาร์ทที่ดีขึ้น ปรับแต่งโดย LCD/Gcode)
    #define TOOLCHANGE_FS_RETRACT_SPEED (50*60) // (มม./นาที) (การขนถ่าย)
    #define TOOLCHANGE_FS_UNRETRACT_SPEED (25*60) // (มม./นาที) (บน SINGLENOZZLE หรือการโหลด Bowden จะต้องช้าลง)

    // ไพรเมอร์ที่ยาวขึ้นเพื่อทำความสะอาดหัวฉีดเดี่ยว
    #define TOOLCHANGE_FS_EXTRA_PRIME 0 // (มม.) ความยาวการรองพื้นพิเศษ
    #define TOOLCHANGE_FS_PRIME_SPEED (4.6*60) // (มม./นาที) อัตราป้อนไพรเมอร์พิเศษ
    #define TOOLCHANGE_FS_WIPE_RETRACT 0 // (มม./นาที) หดกลับก่อนที่จะทำให้เย็นลงเพื่อให้เกิดการตึงน้อยลง เช็ดได้ดีขึ้น ฯลฯ

    // พักให้เย็นหลังการใช้งานเพื่อลดการตึงของสาย
    #define TOOLCHANGE_FS_FAN -1 // ดัชนีพัดลมหรือ -1 เพื่อข้าม
    #define TOOLCHANGE_FS_FAN_SPEED 255 // 0-255
    #define TOOLCHANGE_FS_FAN_TIME 10 // (วินาที)

    // สลับเครื่องอัดรีดที่ยังไม่ได้กำหนดค่าด้วย TOOLCHANGE_FS_PRIME_SPEED สำหรับความยาวทั้งหมด (กู้คืน + ไพรเมอร์)
    // (อาจทำให้เส้นใยขาดได้หากไม่ดึงกลับก่อน)
    //#กำหนด TOOLCHANGE_FS_INIT_BEFORE_SWAP

    // ไพรม์ที่ T0 แรก (ถ้าเป็นอันอื่น จะใช้ TOOLCHANGE_FS_INIT_BEFORE_SWAP)
    // เปิดใช้งาน (M217 V[0/1]) ก่อนพิมพ์ เพื่อหลีกเลี่ยงการไพรเมอร์ที่ไม่ต้องการบนโฮสต์ที่เชื่อมต่อ
    //#กำหนด TOOLCHANGE_FS_PRIME_FIRST_USED

    -
     * การย้ายเครื่องมือเพื่อเปลี่ยนเครื่องมือ
     * คุณสมบัตินี้ให้ตัวเลือก G-code และ LCD เพื่อสลับเครื่องมือระหว่างการพิมพ์
     * คุณสมบัติเครื่องมือที่เกี่ยวข้องทั้งหมดจะถูกย้ายเพื่อให้การพิมพ์สามารถดำเนินการต่อได้
     * เครื่องมือจะต้องตรงกันอย่างใกล้ชิดและอาจมีข้อจำกัดอื่นๆ ที่เกี่ยวข้อง
     * มีประโยชน์ต่อ:
     * - เปลี่ยนสีเส้นใยได้ไม่สะดุด
     * - เปลี่ยนสปูลอัตโนมัติเมื่อเส้นใยหมด
     * - สลับไปใช้หัวฉีดอื่นในกรณีที่หัวฉีดติดขัด
     -
    #กำหนด TOOLCHANGE_MIGRATION_FEATURE

  #สิ้นสุด

  -
   * ตำแหน่งจอดหัวเครื่องมือขณะเปลี่ยนเครื่องมือ
   * ไม่ใช้กับ SWITCHING_TOOLHEAD, DUAL_X_CARRIAGE หรือ PARKING_EXTRUDER
   -
  //#กำหนด TOOLCHANGE_PARK
  #ถ้าเปิดใช้งาน (TOOLCHANGE_PARK)
    #กำหนด TOOLCHANGE_PARK_XY { X_MIN_POS + 10, Y_MIN_POS + 10 }
    #define TOOLCHANGE_PARK_XY_FEEDRATE 6000 // (มม./นาที)
    //#define TOOLCHANGE_PARK_X_ONLY // เคลื่อนที่เฉพาะแกน X
    //#define TOOLCHANGE_PARK_Y_ONLY // เคลื่อนที่เฉพาะแกน Y
  #สิ้นสุด
#endif // HAS_MULTI_EXTRUDER

-
 * หยุดชั่วคราวขั้นสูง
 * คุณลักษณะเชิงทดลองสำหรับการรองรับการเปลี่ยนเส้นใย และสำหรับการจอดหัวฉีดเมื่อหยุดชั่วคราว
 * เพิ่ม GCode M600 เพื่อเริ่มการเปลี่ยนเส้นใย
 * หากเปิดใช้งาน PARK_HEAD_ON_PAUSE จะเพิ่ม GCode M125 เพื่อหยุดการพิมพ์ชั่วคราวและจอดหัวฉีด
 -
 * ต้องใช้จอ LCD
 * ต้องใช้ NOZZLE_PARK_FEATURE
 * คุณสมบัตินี้จำเป็นสำหรับ FILAMENT_RUNOUT_SCRIPT เริ่มต้น
 -
#กำหนดคุณสมบัติ ADVANCED_PAUSE_FEATURE
#ถ้าเปิดใช้งาน (ADVANCED_PAUSE_FEATURE)
  #define PAUSE_PARK_RETRACT_FEEDRATE 60 // (มม./วินาที) อัตราการป้อนการถอยกลับเริ่มต้น
  #define PAUSE_PARK_RETRACT_LENGTH 2 // (มม.) การหดกลับเริ่มต้น
                                                  // การหดสั้นนี้จะทำทันที ก่อนที่จะจอดหัวฉีด
  #define FILAMENT_CHANGE_UNLOAD_FEEDRATE 10 // (mm/s) อัตราป้อนเส้นใยออก ซึ่งค่อนข้างเร็วทีเดียว
  #define FILAMENT_CHANGE_UNLOAD_ACCEL 25 // (mm/s^2) การเร่งความเร็วที่ต่ำลงอาจทำให้มีอัตราฟีดที่เร็วขึ้น
  #define FILAMENT_CHANGE_UNLOAD_LENGTH 400 // (มม.) ความยาวของเส้นใยเมื่อขนถ่ายออกจนหมด
                                                  // สำหรับโบว์เดน ความยาวเต็มของท่อและหัวฉีด
                                                  // สำหรับขับตรงตลอดความยาวของหัวฉีด
                                                  // ตั้งค่าเป็น 0 สำหรับการขนถ่ายด้วยตนเอง
  #define FILAMENT_CHANGE_SLOW_LOAD_FEEDRATE 6 // (มม./วินาที) เคลื่อนที่ช้าเมื่อเริ่มโหลด
  #define FILAMENT_CHANGE_SLOW_LOAD_LENGTH 0 // (มม.) ความยาวช้า เพื่อให้มีเวลาในการแทรกวัสดุ
                                                  // 0 เพื่อปิดการใช้งานการเริ่มโหลดและข้ามไปที่การโหลดเร็วเท่านั้น
  #define FILAMENT_CHANGE_FAST_LOAD_FEEDRATE 6 // (mm/s) โหลดอัตราป้อนเส้นใย ซึ่งค่อนข้างเร็วทีเดียว
  #define FILAMENT_CHANGE_FAST_LOAD_ACCEL 25 // (mm/s^2) การเร่งความเร็วที่ต่ำลงอาจทำให้มีอัตราฟีดที่เร็วขึ้น
  #define FILAMENT_CHANGE_FAST_LOAD_LENGTH 350 // (มม.) ความยาวโหลดของเส้นใยจากเฟืองเครื่องอัดรีดถึงหัวฉีด
                                                  // สำหรับโบว์เดน ความยาวเต็มของท่อและหัวฉีด
                                                  // สำหรับขับตรงตลอดความยาวของหัวฉีด
  //#define ADVANCED_PAUSE_CONTINUOUS_PURGE // ล้างอย่างต่อเนื่องจนถึงระยะเวลาการล้างจนกว่าจะถูกขัดจังหวะ
  #define ADVANCED_PAUSE_PURGE_FEEDRATE 3 // (มม./วินาที) อัตราป้อนอัด (หลังจากโหลด) ควรช้ากว่าอัตราป้อนโหลด
  #define ADVANCED_PAUSE_PURGE_LENGTH 50 // (มม.) ความยาวที่จะอัดออกมาหลังจากการโหลด
                                                  // ตั้งค่าเป็น 0 สำหรับการอัดขึ้นรูปด้วยมือ
                                                  // สามารถอัดเส้นใยซ้ำๆ ได้จากเมนู Filament Change
                                                  // จนกว่าการอัดจะสม่ำเสมอ และทำการล้างเส้นใยเก่าออก
  #define ADVANCED_PAUSE_RESUME_PRIME 0 // (มม.) ระยะทางพิเศษถึงหัวฉีดไพรเมอร์หลังจากกลับมาจากที่จอดรถ
  //#define ADVANCED_PAUSE_FANS_PAUSE // ปิดพัดลมระบายความร้อนการพิมพ์ในขณะที่เครื่องกำลังหยุดชั่วคราว

                                                  // Filament Unload ทำการ Retract, Delay และ Purge ก่อน:
  #define FILAMENT_UNLOAD_PURGE_RETRACT 13 // (มม.) ความยาวการหดกลับเริ่มต้นในการขนถ่าย
  #define FILAMENT_UNLOAD_PURGE_DELAY 5000 // (ms) ความล่าช้าในการทำให้เส้นใยเย็นลงหลังจากหดกลับ
  #define FILAMENT_UNLOAD_PURGE_LENGTH 8 // (mm) การถอดออกเสร็จสิ้น จากนั้นความยาวดังกล่าวก็จะถูกกำจัดออกไป
  #define FILAMENT_UNLOAD_PURGE_FEEDRATE 25 // (มม./วินาที) อัตราป้อนที่จะล้างก่อนขนถ่าย

  #define PAUSE_PARK_NOZZLE_TIMEOUT 45 // (วินาที) ระยะเวลาจำกัดก่อนที่จะปิดหัวฉีดเพื่อความปลอดภัย
  #define FILAMENT_CHANGE_ALERT_BEEPS 10 // จำนวนเสียงบี๊บแจ้งเตือนที่จะเล่นเมื่อจำเป็นต้องมีการตอบสนอง
  #define PAUSE_PARK_NO_STEPPER_TIMEOUT // เปิดใช้งานให้สเต็ปเปอร์ XYZ ยังคงเปิดอยู่ในระหว่างการเปลี่ยนเส้นใย

  #define PARK_HEAD_ON_PAUSE // จอดหัวฉีดในระหว่างหยุดชั่วคราวและเปลี่ยนเส้นใย
  #define HOME_BEFORE_FILAMENT_CHANGE // หากจำเป็น ให้กลับบ้านก่อนจอดรถเพื่อเปลี่ยนเส้นใย

  #define FILAMENT_LOAD_UNLOAD_GCODES // เพิ่มการโหลด/ยกเลิกการโหลด G-code M701/M702 รวมถึงการโหลด/ยกเลิกการโหลดในเมนูเตรียมของ LCD
  //#define FILAMENT_UNLOAD_ALL_EXTRUDERS // อนุญาตให้ M702 ขนถ่ายเครื่องอัดรีดทั้งหมดออกเหนืออุณหภูมิเป้าหมายขั้นต่ำ (ตามที่กำหนดโดย M302)
#สิ้นสุด

// @หมวด tmc

-
 * ตัวเลือกไดรเวอร์สเต็ปเปอร์ TMC26X
 -
 * จำเป็นต้องมีไลบรารี TMC26XStepper สำหรับไดร์เวอร์สเต็ปเปอร์นี้
 * https://github.com/trinamic/TMC26XStepper
 -
#ถ้า HAS_DRIVER (TMC26X)

  #ถ้า AXIS_DRIVER_TYPE_X(TMC26X)
    #กำหนด X_MAX_CURRENT 1000 // (มิลลิแอมป์)
    #define X_SENSE_RESISTOR 91 // (มิลลิโอห์ม)
    #define X_MICROSTEPS 16 // จำนวนไมโครสเต็ป
  #สิ้นสุด

  #ถ้า AXIS_DRIVER_TYPE_X2(TMC26X)
    #กำหนด X2_MAX_CURRENT 1,000
    #กำหนด X2_SENSE_RESISTOR 91
    #กำหนด X2_MICROSTEPS 16
  #สิ้นสุด

  #ถ้า AXIS_DRIVER_TYPE_Y(TMC26X)
    #กำหนด Y_MAX_CURRENT 1,000
    #กำหนด Y_SENSE_RESISTOR 91
    #กำหนด Y_MICROSTEPS 16
  #สิ้นสุด

  #ถ้า AXIS_DRIVER_TYPE_Y2(TMC26X)
    #กำหนด Y2_MAX_CURRENT 1,000
    #กำหนด Y2_SENSE_RESISTOR 91
    #กำหนด Y2_MICROSTEPS 16
  #สิ้นสุด

  #ถ้า AXIS_DRIVER_TYPE_Z(TMC26X)
    #กำหนด Z_MAX_CURRENT 1,000
    #กำหนด Z_SENSE_RESISTOR 91
    #กำหนด Z_MICROSTEPS 16
  #สิ้นสุด

  #ถ้า AXIS_DRIVER_TYPE_Z2(TMC26X)
    #กำหนด Z2_MAX_CURRENT 1,000
    #กำหนด Z2_SENSE_RESISTOR 91
    #กำหนด Z2_MICROSTEPS 16
  #สิ้นสุด

  #ถ้า AXIS_DRIVER_TYPE_Z3(TMC26X)
    #กำหนด Z3_MAX_CURRENT 1000
    #กำหนด Z3_SENSE_RESISTOR 91
    #กำหนด Z3_MICROSTEPS 16
  #สิ้นสุด

  #ถ้า AXIS_DRIVER_TYPE_Z4(TMC26X)
    #กำหนด Z4_MAX_CURRENT 1000
    #กำหนด Z4_SENSE_RESISTOR 91
    #กำหนด Z4_MICROSTEPS 16
  #สิ้นสุด

  #ถ้า AXIS_DRIVER_TYPE_E0(TMC26X)
    #กำหนด E0_MAX_CURRENT 1,000
    #กำหนด E0_SENSE_RESISTOR 91
    #กำหนด E0_MICROSTEPS 16
  #สิ้นสุด

  #ถ้า AXIS_DRIVER_TYPE_E1(TMC26X)
    #กำหนด E1_MAX_CURRENT 1,000
    #กำหนด E1_SENSE_RESISTOR 91
    #กำหนด E1_MICROSTEPS 16
  #สิ้นสุด

  #ถ้า AXIS_DRIVER_TYPE_E2(TMC26X)
    #กำหนด E2_MAX_CURRENT 1,000
    #กำหนด E2_SENSE_RESISTOR 91
    #กำหนด E2_MICROSTEPS 16
  #สิ้นสุด

  #ถ้า AXIS_DRIVER_TYPE_E3(TMC26X)
    #กำหนด E3_MAX_CURRENT 1,000
    #กำหนด E3_SENSE_RESISTOR 91
    #กำหนด E3_MICROSTEPS 16
  #สิ้นสุด

  #ถ้า AXIS_DRIVER_TYPE_E4(TMC26X)
    #กำหนด E4_MAX_CURRENT 1,000
    #กำหนด E4_SENSE_RESISTOR 91
    #กำหนด E4_MICROSTEPS 16
  #สิ้นสุด

  #ถ้า AXIS_DRIVER_TYPE_E5(TMC26X)
    #กำหนด E5_MAX_CURRENT 1,000
    #กำหนด E5_SENSE_RESISTOR 91
    #กำหนด E5_MICROSTEPS 16
  #สิ้นสุด

  #ถ้า AXIS_DRIVER_TYPE_E6(TMC26X)
    #กำหนด E6_MAX_CURRENT 1,000
    #กำหนด E6_SENSE_RESISTOR 91
    #กำหนด E6_MICROSTEPS 16
  #สิ้นสุด

  #ถ้า AXIS_DRIVER_TYPE_E7(TMC26X)
    #กำหนด E7_MAX_CURRENT 1000
    #กำหนด E7_SENSE_RESISTOR 91
    #กำหนด E7_MICROSTEPS 16
  #สิ้นสุด

#สิ้นสุด // TMC26X

// @หมวด tmc_smart

-
 * เพื่อใช้ไดรเวอร์สเต็ปเปอร์ TMC2130, TMC2160, TMC2660, TMC5130, TMC5160 ในโหมด SPI
 * เชื่อมต่อพิน SPI ของคุณเข้ากับอินเทอร์เฟซฮาร์ดแวร์ SPI บนบอร์ดของคุณและกำหนด
 * พิน CS ที่จำเป็นในไฟล์ `pins_MYBOARD.h` ของคุณ (เช่น RAMPS 1.4 ใช้ AUX3
 * พิน `X_CS_PIN 53`, `Y_CS_PIN 49` เป็นต้น)
 * คุณยังสามารถใช้ซอฟต์แวร์ SPI ได้หากต้องการใช้พิน IO วัตถุประสงค์ทั่วไป
 -
 * หากต้องการใช้ไดรเวอร์สเต็ปเปอร์ TMC2208 ที่กำหนดค่า UART ได้ ให้เชื่อมต่อ #_SERIAL_TX_PIN
 * ไปยังพิน PDN_UART ฝั่งไดรเวอร์ด้วยตัวต้านทาน 1K
 * เพื่อใช้ความสามารถในการอ่าน ให้เชื่อมต่อ #_SERIAL_RX_PIN กับ PDN_UART โดยไม่ต้อง
 * ตัวต้านทาน
 * ไดร์เวอร์ยังสามารถใช้งานร่วมกับฮาร์ดแวร์ซีเรียลได้
 -
 * จำเป็นต้องมีไลบรารี TMCStepper เพื่อใช้ไดรเวอร์สเต็ปเปอร์ TMC
 * https://github.com/teemuatlut/TMCStepper
 -
#ถ้ามี HAS_TRINAMIC_CONFIG

  #define HOLD_MULTIPLIER 0.5 // ลดขนาดกระแสยึดจากกระแสทำงาน
  #define INTERPOLATE true // แทรกค่า X/Y/Z_MICROSTEPS เป็น 256

  #ถ้า AXIS_IS_TMC(X)
    #define X_CURRENT 580 // กระแส RMS (mA) คูณด้วย 1.414 สำหรับกระแสสูงสุด
    #define X_CURRENT_HOME (X_CURRENT/2) // (mA) กระแส RMS สำหรับการกลับสู่ตำแหน่งเดิมแบบไร้เซ็นเซอร์
    #กำหนด X_MICROSTEPS 16 // 0..256
    #กำหนด X_RSENSE 0.11
    #define X_CHAIN_POS -1 // <=0 : ไม่ได้เชื่อมต่อแบบโซ่ 1 : เชื่อมต่อ MCU MOSI แล้ว 2 : ถัดไปในโซ่ ...
  #สิ้นสุด

  #ถ้า AXIS_IS_TMC(X2)
    #กำหนด X2_CURRENT 800
    #กำหนด X2_CURRENT_HOME X2_CURRENT
    #กำหนด X2_MICROSTEPS 16
    #กำหนด X2_RSENSE 0.11
    #กำหนด X2_CHAIN_POS -1
  #สิ้นสุด

  #ถ้า AXIS_IS_TMC(Y)
    #กำหนด Y_CURRENT 580
    #กำหนด Y_CURRENT_HOME (Y_CURRENT/2)
    #กำหนด Y_MICROSTEPS 16
    #กำหนด Y_RSENSE 0.11
    #กำหนด Y_CHAIN_POS -1
  #สิ้นสุด

  #ถ้า AXIS_IS_TMC(Y2)
    #กำหนด Y2_CURRENT 800
    #กำหนด Y2_CURRENT_HOME Y2_CURRENT
    #กำหนด Y2_MICROSTEPS 16
    #กำหนด Y2_RSENSE 0.11
    #กำหนด Y2_CHAIN_POS -1
  #สิ้นสุด

  #ถ้า AXIS_IS_TMC(Z)
    #กำหนด Z_CURRENT 580
    #กำหนด Z_CURRENT_HOME Z_CURRENT
    #กำหนด Z_MICROSTEPS 16
    #กำหนด Z_RSENSE 0.11
    #กำหนด Z_CHAIN_POS -1
  #สิ้นสุด

  #ถ้า AXIS_IS_TMC(Z2)
    #กำหนด Z2_CURRENT 800
    #กำหนด Z2_CURRENT_HOME Z2_CURRENT
    #กำหนด Z2_MICROSTEPS 16
    #กำหนด Z2_RSENSE 0.11
    #กำหนด Z2_CHAIN_POS -1
  #สิ้นสุด

  #ถ้า AXIS_IS_TMC(Z3)
    #กำหนด Z3_CURRENT 800
    #กำหนด Z3_CURRENT_HOME Z3_CURRENT
    #กำหนด Z3_MICROSTEPS 16
    #กำหนด Z3_RSENSE 0.11
    #กำหนด Z3_CHAIN_POS -1
  #สิ้นสุด

  #ถ้า AXIS_IS_TMC(Z4)
    #กำหนด Z4_CURRENT 800
    #กำหนด Z4_CURRENT_HOME Z4_CURRENT
    #กำหนด Z4_MICROSTEPS 16
    #กำหนด Z4_RSENSE 0.11
    #กำหนด Z4_CHAIN_POS -1
  #สิ้นสุด

  #ถ้า AXIS_IS_TMC(E0)
    #กำหนด E0_CURRENT 650
    #กำหนด E0_MICROSTEPS 16
    #กำหนด E0_RSENSE 0.11
    #กำหนด E0_CHAIN_POS -1
  #สิ้นสุด

  #ถ้า AXIS_IS_TMC(E1)
    #กำหนด E1_CURRENT 650
    #กำหนด E1_MICROSTEPS 16
    #กำหนด E1_RSENSE 0.11
    #กำหนด E1_CHAIN_POS -1
  #สิ้นสุด

  #ถ้า AXIS_IS_TMC(E2)
    #กำหนด E2_CURRENT 800
    #กำหนด E2_MICROSTEPS 16
    #กำหนด E2_RSENSE 0.11
    #กำหนด E2_CHAIN_POS -1
  #สิ้นสุด

  #ถ้า AXIS_IS_TMC(E3)
    #กำหนด E3_CURRENT 800
    #กำหนด E3_MICROSTEPS 16
    #กำหนด E3_RSENSE 0.11
    #กำหนด E3_CHAIN_POS -1
  #สิ้นสุด

  #ถ้า AXIS_IS_TMC(E4)
    #กำหนด E4_CURRENT 800
    #กำหนด E4_MICROSTEPS 16
    #กำหนด E4_RSENSE 0.11
    #กำหนด E4_CHAIN_POS -1
  #สิ้นสุด

  #ถ้า AXIS_IS_TMC(E5)
    #กำหนด E5_CURRENT 800
    #กำหนด E5_MICROSTEPS 16
    #กำหนด E5_RSENSE 0.11
    #กำหนด E5_CHAIN_POS -1
  #สิ้นสุด

  #ถ้า AXIS_IS_TMC(E6)
    #กำหนด E6_CURRENT 800
    #กำหนด E6_MICROSTEPS 16
    #กำหนด E6_RSENSE 0.11
    #กำหนด E6_CHAIN_POS -1
  #สิ้นสุด

  #ถ้า AXIS_IS_TMC(E7)
    #กำหนด E7_CURRENT 800
    #กำหนด E7_MICROSTEPS 16
    #กำหนด E7_RSENSE 0.11
    #กำหนด E7_CHAIN_POS -1
  #สิ้นสุด

  -
   * การแทนที่พิน SPI เริ่มต้นสำหรับไดรเวอร์ TMC2130, TMC2160, TMC2660, TMC5130 และ TMC5160 ที่นี่
   * พินเริ่มต้นสามารถพบได้ในไฟล์พินของบอร์ดของคุณ
   -
  //#กำหนด X_CS_PIN -1
  //#กำหนด Y_CS_PIN -1
  //#กำหนด Z_CS_PIN -1
  //#กำหนด X2_CS_PIN -1
  //#กำหนด Y2_CS_PIN -1
  //#กำหนด Z2_CS_PIN -1
  //#กำหนด Z3_CS_PIN -1
  //#กำหนด E0_CS_PIN -1
  //#กำหนด E1_CS_PIN -1
  //#กำหนด E2_CS_PIN -1
  //#กำหนด E3_CS_PIN -1
  //#กำหนด E4_CS_PIN -1
  //#กำหนด E5_CS_PIN -1
  //#กำหนด E6_CS_PIN -1
  //#กำหนด E7_CS_PIN -1

  -
   * ตัวเลือกซอฟต์แวร์สำหรับไดร์เวอร์ที่ขับเคลื่อนโดย SPI (TMC2130, TMC2160, TMC2660, TMC5130 และ TMC5160)
   * พิน SPI ของ SW เริ่มต้นถูกกำหนดโดยไฟล์พินที่เกี่ยวข้อง
   * แต่คุณสามารถแทนที่หรือกำหนดค่าได้ที่นี่
   -
  //#กำหนด TMC_USE_SW_SPI
  //#กำหนด TMC_SW_MOSI -1
  //#กำหนด TMC_SW_MISO -1
  //#กำหนด TMC_SW_SCK -1

  -
   * ไดรเวอร์ TMC2209 สี่ตัวสามารถใช้พอร์ตซีเรียล HW/SW เดียวกันโดยมีที่อยู่ที่กำหนดค่าด้วยฮาร์ดแวร์
   * ตั้งค่าที่อยู่โดยใช้จัมเปอร์บนพิน MS1 และ MS2
   * ที่อยู่ | MS1 | MS2
   * 0 | ต่ำ | ต่ำ
   * 1 | สูง | ต่ำ
   * 2 | ต่ำ | สูง
   * 3 | สูง | สูง
   -
   * ตั้งค่า *_SERIAL_TX_PIN และ *_SERIAL_RX_PIN ให้ตรงกับไดรเวอร์ทั้งหมด
   * บนพอร์ตซีเรียลเดียวกัน ไม่ว่าจะที่นี่หรือในไฟล์พินของบอร์ดของคุณ
   -
  #กำหนด X_SLAVE_ADDRESS 0
  #กำหนด Y_SLAVE_ADDRESS 0
  #กำหนด Z_SLAVE_ADDRESS 0
  #กำหนด X2_SLAVE_ADDRESS 0
  #กำหนด Y2_SLAVE_ADDRESS 0
  #กำหนด Z2_SLAVE_ADDRESS 0
  #กำหนด Z3_SLAVE_ADDRESS 0
  #กำหนด Z4_SLAVE_ADDRESS 0
  #กำหนด E0_SLAVE_ADDRESS 0
  #กำหนด E1_SLAVE_ADDRESS 0
  #กำหนด E2_SLAVE_ADDRESS 0
  #กำหนด E3_SLAVE_ADDRESS 0
  #กำหนด E4_SLAVE_ADDRESS 0
  #กำหนด E5_SLAVE_ADDRESS 0
  #กำหนด E6_SLAVE_ADDRESS 0
  #กำหนด E7_SLAVE_ADDRESS 0

  -
   * เปิดใช้งานซอฟต์แวร์
   -
   * ใช้สำหรับไดร์เวอร์ที่ไม่ได้ใช้พินเปิดใช้งานเฉพาะ แต่ใช้จัดการแบบเดียวกัน
   * ทำงานผ่านสายการสื่อสาร เช่น SPI หรือ UART
   -
  //#กำหนด SOFTWARE_DRIVER_ENABLE

  -
   * TMC2130, TMC2160, TMC2208, TMC2209, TMC5130 และ TMC5160 เท่านั้น
   * ใช้โหมดการก้าวที่เงียบเป็นพิเศษของ Trinamic
   * เมื่อปิดใช้งาน Marlin จะใช้โหมดการก้าวแบบกระจายรอบ
   -
  #กำหนด STEALTHCHOP_XY
  #กำหนด STEALTHCHOP_Z
  #กำหนด STEALTHCHOP_E

  -
   * เพิ่มประสิทธิภาพพารามิเตอร์ของ SpreadCycle Chopper โดยใช้ชุดพารามิเตอร์ที่กำหนดไว้ล่วงหน้า
   *หรือด้วยความช่วยเหลือของตัวอย่างที่รวมอยู่ในห้องสมุด
   * ชุดพารามิเตอร์ที่ให้ไว้คือ
   * สับเริ่มต้น_12V
   * สับเริ่มต้น_19V
   * สับเริ่มต้น_24V
   * สับเริ่มต้น_36V
   * CHOPPER_09STEP_24V // สเต็ปเปอร์ 0.9 องศา (24V)
   * CHOPPER_PRUSAMK3_24V // นำเข้าพารามิเตอร์จากเฟิร์มแวร์ Prลฏกาอย่างเป็นทางการสำหรับ MK3 (24V)
   * CHOPPER_MARLIN_119 // ค่าเริ่มต้นเก่าจาก Marlin v1.1.9
   -
   * กำหนดความเป็นเจ้าของของคุณด้วย
   * { <ปิดเวลา[1..15]>, <สิ้นสุดไฮสเทอรีซิส[-3..12]>, เริ่มต้นไฮสเทอรีซิส[1..8] }
   -
  #กำหนดระยะเวลา CHOPPER_DEFAULT_24V

  -
   * ตรวจสอบไดร์เวอร์ Trinamic
   * สำหรับสภาวะข้อผิดพลาด เช่น อุณหภูมิเกินและการลัดวงจรลงกราวด์
   * เพื่อจัดการกับอุณหภูมิที่เกิน Marlin สามารถลดกระแสไดรเวอร์ได้จนกว่าเงื่อนไขข้อผิดพลาดจะได้รับการแก้ไข
   * สามารถใช้เงื่อนไขที่ตรวจพบอื่น ๆ เพื่อหยุดการพิมพ์ปัจจุบันได้
   * G-code ที่เกี่ยวข้อง:
   * M906 - ตั้งค่าหรือรับกระแสมอเตอร์เป็นมิลลิแอมป์โดยใช้รหัสแกน X, Y, Z, E รายงานค่าหากไม่มีการระบุรหัสแกน
   * M911 - รายงานสภาวะเตือนล่วงหน้าเกี่ยวกับอุณหภูมิเกินของไดร์เวอร์สเต็ปเปอร์
   * M912 - ล้างสถานะการเตือนล่วงหน้าอุณหภูมิเกินของไดร์เวอร์สเต็ปเปอร์
   * M122 - รายงานพารามิเตอร์ไดรเวอร์ (ต้องใช้ TMC_DEBUG)
   -
  //#กำหนดสถานะ MONITOR_DRIVER_STATUS

  #ถ้าเปิดใช้งาน (สถานะ MONITOR_DRIVER_STATUS)
    #define CURRENT_STEP_DOWN 50 // [mA]
    #กำหนดรายงานการเปลี่ยนแปลงปัจจุบัน
    #กำหนด STOP_ON_ERROR
  #สิ้นสุด

  -
   * TMC2130, TMC2160, TMC2208, TMC2209, TMC5130 และ TMC5160 เท่านั้น
   * ไดรเวอร์จะสลับไปใช้ spreadCycle เมื่อความเร็วสเต็ปเปอร์เกิน HYBRID_THRESHOLD
   * โหมดนี้ช่วยให้เคลื่อนไหวได้เร็วขึ้นแต่ก็มีระดับเสียงที่สูงขึ้นด้วย
   * ต้องเปิดใช้งาน STEALTHCHOP_(XY|Z|E) เพื่อใช้ HYBRID_THRESHOLD
   * M913 X/Y/Z/E เพื่อปรับแต่งการตั้งค่าแบบสด
   -
  //#กำหนด HYBRID_THRESHOLD

  #define X_HYBRID_THRESHOLD 100 // [มม./วินาที]
  #กำหนด X2_HYBRID_THRESHOLD 100
  #กำหนด Y_HYBRID_THRESHOLD 100
  #กำหนด Y2_HYBRID_THRESHOLD 100
  #กำหนด Z_HYBRID_THRESHOLD 3
  #กำหนด Z2_HYBRID_THRESHOLD 3
  #กำหนด Z3_HYBRID_THRESHOLD 3
  #กำหนด Z4_HYBRID_THRESHOLD 3
  #กำหนด E0_HYBRID_THRESHOLD 30
  #กำหนด E1_HYBRID_THRESHOLD 30
  #กำหนด E2_HYBRID_THRESHOLD 30
  #กำหนด E3_HYBRID_THRESHOLD 30
  #กำหนด E4_HYBRID_THRESHOLD 30
  #กำหนด E5_HYBRID_THRESHOLD 30
  #กำหนด E6_HYBRID_THRESHOLD 30
  #กำหนด E7_HYBRID_THRESHOLD 30

  -
   * ใช้ StallGuard เพื่อค้นหาตำแหน่งเริ่มต้น/ตรวจจับ X, Y, Z
   -
   * TMC2130, TMC2160, TMC2209, TMC2660, TMC5130 และ TMC5160 เท่านั้น
   * เชื่อมต่อพิน DIAG1 ของไดร์เวอร์สเต็ปเปอร์เข้ากับพินเอนด์สต็อป X/Y
   * การกลับสู่ตำแหน่ง X, Y และ Z จะดำเนินการในโหมด spreadCycle เสมอ
   -
   * X/Y/Z_STALL_SENSITIVITY คือเกณฑ์การหยุดทำงานเริ่มต้น
   * ใช้ M914 XYZ เพื่อตั้งค่าเกณฑ์การหยุดทำงานในระหว่างการทำงาน:
   -
   * ความไวแสง TMC2209 อื่นๆ
   * สูงสุด 255 -64 (อ่อนไหวเกินไป => บวกเท็จ)
   * ต่ำสุด 0 63 (ไม่ไวเกินไป => ไม่มีทริกเกอร์)
   -
   * ขอแนะนำให้ตั้งค่า HOMING_BUMP_MM เป็น { 0, 0, 0 }
   -
   * SPI_ENDSTOPS *** ฟีเจอร์เบต้า! *** TMC2130 เท่านั้น ***
   * สำรวจไดรเวอร์ผ่าน SPI เพื่อกำหนดโหลดเมื่อกลับสู่จุดเริ่มต้น
   * ไม่ต้องใช้สายจาก DIAG1 ไปที่พินเอ็นสต็อป
   -
   * IMPROVE_HOMING_RELIABILITY ปรับแต่งการเร่งความเร็วและการกระตุกเมื่อ
   * การกลับสู่จุดเริ่มต้นและเพิ่มช่วงเวลาการป้องกันสำหรับการทริกเกอร์การหยุดชั่วคราว
   -
   * ความคิดเห็น *_STALL_SENSITIVITY เพื่อปิดใช้งานการกลับสู่จุดเริ่มต้นแบบไร้เซ็นเซอร์สำหรับแกนนั้น
   -
  //#define Sensorless_HOMING // เฉพาะไดรเวอร์ที่รองรับ StallGuard เท่านั้น

  #ถ้า EITHER(SENSORLESS_HOMING, Sensorless_PROBING)
    // TMC2209: 0...255. TMC2130: -64...63
    #กำหนด X_STALL_SENSITIVITY 75
    #กำหนด X2_STALL_SENSITIVITY X_STALL_SENSITIVITY
    #กำหนด Y_STALL_SENSITIVITY 75
    #กำหนด Y2_STALL_SENSITIVITY Y_STALL_SENSITIVITY
    //#กำหนด Z_STALL_SENSITIVITY 8
    //#กำหนด Z2_STALL_SENSITIVITY Z_STALL_SENSITIVITY
    //#กำหนด Z3_STALL_SENSITIVITY Z_STALL_SENSITIVITY
    //#กำหนด Z4_STALL_SENSITIVITY Z_STALL_SENSITIVITY
    //#define SPI_ENDSTOPS // TMC2130 เท่านั้น
    #defineปรับปรุงความน่าเชื่อถือของ HOMING
  #สิ้นสุด

  -
   * เฟสการโฮมมิ่ง TMC
   -
   * ปรับปรุงความสามารถในการทำซ้ำการกลับสู่จุดเริ่มต้นโดยการกลับสู่จุดเริ่มต้นที่ใกล้ที่สุดของขดลวดสเต็ปเปอร์
   * ตำแหน่งเฟส ไดรเวอร์ Trinamic ใช้ตารางเฟสสเต็ปเปอร์ที่มีค่า 1,024
   * ครอบคลุม 4 ขั้นเต็ม โดยแต่ละขั้นมีตำแหน่ง 256 ตำแหน่ง (ดังนั้นจึงมี 1,024 ตำแหน่ง)
   * ตำแหน่งขั้นเต็ม (128, 384, 640, 896) มีแรงบิดยึดสูงสุด
   -
   * ค่าตั้งแต่ 0..1023, -1 เพื่อปิดใช้งานเฟสกลับสู่จุดเริ่มต้นสำหรับแกนนั้น
   -
   //#กำหนด TMC_HOME_PHASE { 896, 896, 896 }

  -
   * ฟีเจอร์เบต้า!
   * สร้างพัลส์สเต็ปเปอร์คลื่นสี่เหลี่ยม 50/50 ซึ่งเหมาะสมที่สุดสำหรับไดรเวอร์สเต็ปเปอร์
   -
  #กำหนด SQUARE_WAVE_STEPPING

  -
   * เปิดใช้งานคำสั่งดีบัก M122 สำหรับไดร์เวอร์สเต็ปเปอร์ TMC
   * M122 S0/1 จะทำให้สามารถรายงานอย่างต่อเนื่องได้
   -
  //#กำหนด TMC_DEBUG

  -
   * คุณสามารถตั้งค่าขั้นสูงของคุณเองได้โดยการกรอกฟังก์ชั่นที่กำหนดไว้ล่วงหน้า
   * รายชื่อฟังก์ชันที่ใช้งานได้สามารถดูได้ที่หน้า GitHub ของไลบรารี
   * https://github.com/teemuatlut/TMCStepper
   -
   * ตัวอย่าง:
   * #กำหนด TMC_ADV() { \
   * stepperX.diag0_otpw(1); \
   * stepperY.intpol(0); \
   -
   -
  #กำหนด TMC_ADV() { }

#endif // HAS_TRINAMIC_CONFIG

// @ส่วน L64XX

-
 * ตัวเลือกไดรเวอร์สเต็ปเปอร์ L64XX
 -
 * จำเป็นต้องมีไลบรารี Arduino-L6470 (0.8.0 หรือสูงกว่า)
 * https://github.com/ameyer/Arduino-L6470
 -
 * จำเป็นต้องกำหนดสิ่งต่อไปนี้ในไฟล์ pins_YOUR_BOARD ของคุณ
 * L6470_CHAIN_SCK_พิน
 * L6470_CHAIN_MISO_PIN
 * L6470_CHAIN_MOSI_PIN
 * L6470_CHAIN_SS_PIN
 * ENABLE_RESET_L64XX_CHIPS(Q) โดยที่ Q คือ 1 เพื่อเปิดใช้งานและ 0 เพื่อรีเซ็ต
 -

#ถ้า HAS_L64XX

  //#define L6470_CHITCHAT // แสดงข้อมูลสถานะเพิ่มเติม

  #ถ้า AXIS_IS_L64XX(X)
    #define X_MICROSTEPS 128 // จำนวนไมโครสเต็ป (ใช้ได้: 1, 2, 4, 8, 16, 32, 128) - ค่าสูงสุดของ L6474 คือ 16
    #define X_OVERCURRENT 2000 // (mA) กระแสไฟที่ไดรเวอร์ตรวจพบว่ามีกระแสไฟเกิน
                                    // L6470 & L6474 - ใช้ได้: 375 x (1 - 16) - สูงสุด 6A - ปัดลง
                                    // POWERSTEP01: ถูกต้อง: 1000 x (1 - 32) - สูงสุด 32A - ปัดลง
    #define X_STALLCURRENT 1500 // (mA) กระแสไฟที่คนขับตรวจพบว่ารถดับ (ค่าที่ถูกต้อง: 31.25 * (1-128) - สูงสุด 4A - ปัดลง)
                                    // L6470 & L6474 - ใช้ได้: 31.25 * (1-128) - สูงสุด 4A - ปัดลง
                                    // POWERSTEP01: ใช้ได้: 200 x (1 - 32) - สูงสุด 6.4A - ปัดลง
                                    // L6474 - การตั้งค่า STALLCURRENT ใช้เพื่อตั้งค่ากระแสไฟฟ้าที่กำหนด (TVAL)
    #define X_MAX_VOLTAGE 127 // 0-255 แรงดันไฟฟ้าที่มีประสิทธิภาพสูงสุดที่สเต็ปเปอร์มองเห็น - ไม่ได้ใช้โดย L6474
    #define X_CHAIN_POS -1 // ตำแหน่งในเชน SPI, 0=ไม่อยู่ในเชน, 1=MOSI ที่ใกล้ที่สุด
    #define X_SLEW_RATE 1 // 0-3, Slew 0 ช้าที่สุด, 3 เร็วที่สุด
  #สิ้นสุด

  #ถ้า AXIS_IS_L64XX(X2)
    #กำหนด X2_MICROSTEPS 128
    #กำหนด X2_OVERCURRENT 2000
    #กำหนด X2_STALLCURRENT 1500
    #กำหนด X2_MAX_VOLTAGE 127
    #กำหนด X2_CHAIN_POS -1
    #กำหนด X2_SLEW_RATE 1
  #สิ้นสุด

  #ถ้า AXIS_IS_L64XX(Y)
    #กำหนด Y_MICROSTEPS 128
    #กำหนด Y_OVERCURRENT 2000
    #กำหนด Y_STALLCURRENT 1500
    #กำหนด Y_MAX_VOLTAGE 127
    #กำหนด Y_CHAIN_POS -1
    #กำหนด Y_SLEW_RATE 1
  #สิ้นสุด

  #ถ้า AXIS_IS_L64XX(Y2)
    #กำหนด Y2_MICROSTEPS 128
    #กำหนด Y2_OVERCURRENT 2000
    #กำหนด Y2_STALLCURRENT 1500
    #กำหนด Y2_MAX_VOLTAGE 127
    #กำหนด Y2_CHAIN_POS -1
    #กำหนด Y2_SLEW_RATE 1
  #สิ้นสุด

  #ถ้า AXIS_IS_L64XX(Z)
    #กำหนด Z_MICROSTEPS 128
    #กำหนด Z_OVERCURRENT 2000
    #กำหนด Z_STALLCURRENT 1500
    #กำหนด Z_MAX_VOLTAGE 127
    #กำหนด Z_CHAIN_POS -1
    #กำหนด Z_SLEW_RATE 1
  #สิ้นสุด

  #ถ้า AXIS_IS_L64XX(Z2)
    #กำหนด Z2_MICROSTEPS 128
    #กำหนด Z2_OVERCURRENT 2000
    #กำหนด Z2_STALLCURRENT 1500
    #กำหนด Z2_MAX_VOLTAGE 127
    #กำหนด Z2_CHAIN_POS -1
    #กำหนด Z2_SLEW_RATE 1
  #สิ้นสุด

  #ถ้า AXIS_IS_L64XX(Z3)
    #กำหนด Z3_MICROSTEPS 128
    #กำหนด Z3_OVERCURRENT 2000
    #กำหนด Z3_STALLCURRENT 1500
    #กำหนด Z3_MAX_VOLTAGE 127
    #กำหนด Z3_CHAIN_POS -1
    #กำหนด Z3_SLEW_RATE 1
  #สิ้นสุด

  #ถ้า AXIS_IS_L64XX(Z4)
    #กำหนด Z4_MICROSTEPS 128
    #กำหนด Z4_OVERCURRENT 2000
    #กำหนด Z4_STALLCURRENT 1500
    #กำหนด Z4_MAX_VOLTAGE 127
    #กำหนด Z4_CHAIN_POS -1
    #กำหนด Z4_SLEW_RATE 1
  #สิ้นสุด

  #ถ้า AXIS_IS_L64XX(E0)
    #กำหนด E0_MICROSTEPS 128
    #กำหนด E0_OVERCURRENT 2000
    #กำหนด E0_STALLCURRENT 1500
    #กำหนด E0_MAX_VOLTAGE 127
    #กำหนด E0_CHAIN_POS -1
    #กำหนด E0_SLEW_RATE 1
  #สิ้นสุด

  #ถ้า AXIS_IS_L64XX(E1)
    #กำหนด E1_MICROSTEPS 128
    #กำหนด E1_OVERCURRENT 2000
    #กำหนด E1_STALLCURRENT 1500
    #กำหนด E1_MAX_VOLTAGE 127
    #กำหนด E1_CHAIN_POS -1
    #กำหนด E1_SLEW_RATE 1
  #สิ้นสุด

  #ถ้า AXIS_IS_L64XX(E2)
    #กำหนด E2_MICROSTEPS 128
    #กำหนด E2_OVERCURRENT 2000
    #กำหนด E2_STALLCURRENT 1500
    #กำหนด E2_MAX_VOLTAGE 127
    #กำหนด E2_CHAIN_POS -1
    #กำหนด E2_SLEW_RATE 1
  #สิ้นสุด

  #ถ้า AXIS_IS_L64XX(E3)
    #กำหนด E3_MICROSTEPS 128
    #กำหนด E3_OVERCURRENT 2000
    #กำหนด E3_STALLCURRENT 1500
    #กำหนด E3_MAX_VOLTAGE 127
    #กำหนด E3_CHAIN_POS -1
    #กำหนด E3_SLEW_RATE 1
  #สิ้นสุด

  #ถ้า AXIS_IS_L64XX(E4)
    #กำหนด E4_MICROSTEPS 128
    #กำหนด E4_OVERCURRENT 2000
    #กำหนด E4_STALLCURRENT 1500
    #กำหนด E4_MAX_VOLTAGE 127
    #กำหนด E4_CHAIN_POS -1
    #กำหนด E4_SLEW_RATE 1
  #สิ้นสุด

  #ถ้า AXIS_IS_L64XX(E5)
    #กำหนด E5_MICROSTEPS 128
    #กำหนด E5_OVERCURRENT 2000
    #กำหนด E5_STALLCURRENT 1500
    #กำหนด E5_MAX_VOLTAGE 127
    #กำหนด E5_CHAIN_POS -1
    #กำหนด E5_SLEW_RATE 1
  #สิ้นสุด

  #ถ้า AXIS_IS_L64XX(E6)
    #กำหนด E6_MICROSTEPS 128
    #กำหนด E6_OVERCURRENT 2000
    #กำหนด E6_STALLCURRENT 1500
    #กำหนด E6_MAX_VOLTAGE 127
    #กำหนด E6_CHAIN_POS -1
    #กำหนด E6_SLEW_RATE 1
  #สิ้นสุด

  #ถ้า AXIS_IS_L64XX(E7)
    #กำหนด E7_MICROSTEPS 128
    #กำหนด E7_OVERCURRENT 2000
    #กำหนด E7_STALLCURRENT 1500
    #กำหนด E7_MAX_VOLTAGE 127
    #กำหนด E7_CHAIN_POS -1
    #กำหนด E7_SLEW_RATE 1
  #สิ้นสุด

  -
   * ตรวจสอบไดรเวอร์ L6470 เพื่อดูสภาวะข้อผิดพลาด เช่น อุณหภูมิเกินและกระแสไฟเกิน
   * ในกรณีที่อุณหภูมิเกิน Marlin สามารถลดไดรฟ์ได้จนกว่าเงื่อนไขข้อผิดพลาดจะได้รับการแก้ไข
   * สามารถใช้เงื่อนไขที่ตรวจพบอื่น ๆ เพื่อหยุดการพิมพ์ปัจจุบันได้
   * G-code ที่เกี่ยวข้อง:
   * M906 - I1/2/3/4/5 ตั้งค่าหรือรับระดับไดรฟ์มอเตอร์โดยใช้รหัสแกน X, Y, Z, E รายงานค่าหากไม่มีการระบุรหัสแกน
   * ฉันไม่อยู่หรือ I0 หรือ I1 - X, Y, Z หรือ E0
   * I2 - X2, Y2, Z2 หรือ E1
   * I3 - Z3 หรือ E3
   * I4 - Z4 หรือ E4
   * ไอ5 - อี5
   * M916 - เพิ่มระดับไดรฟ์จนกว่าจะได้รับคำเตือนความร้อน
   * M917 - ค้นหาเกณฑ์กระแสไฟขั้นต่ำ
   * M918 - เพิ่มความเร็วจนถึงสูงสุดหรือเกิดข้อผิดพลาด
   * M122 S0/1 - รายงานพารามิเตอร์ไดรเวอร์
   -
  //#กำหนดสถานะ MONITOR_L6470_DRIVER_STATUS

  #ถ้าเปิดใช้งาน (สถานะ MONITOR_L6470_DRIVER_STATUS)
    #กำหนด KVAL_HOLD_STEP_DOWN 1
    //#กำหนด L6470_STOP_ON_ERROR
  #สิ้นสุด

#สิ้นสุด // HAS_L64XX

// @ส่วน i2cbus

-
// I2C Master ID สำหรับ LCD LPC176x และการควบคุมกระแสดิจิตอล
// ไม่ใช้กับอุปกรณ์ต่อพ่วงอื่นๆ ตามไลบรารี Wire
-
//#define I2C_MASTER_ID 1 // ตั้งค่าจาก 0 ถึง 2

-
 * บัส TWI/I2C
 -
 * คุณลักษณะนี้เป็นคุณลักษณะทดลอง ดังนั้นจึงไม่ควรใช้ในการผลิต
 * เครื่องจักร การเปิดใช้งานนี้จะทำให้คุณสามารถส่งและรับข้อมูล I2C จากสเลฟได้
 * อุปกรณ์บนบัส
 -
 * ; ตัวอย่างที่ 1
 * ; แมโครนี้ส่งสตริง "Marlin" ไปยังอุปกรณ์สเลฟที่มีที่อยู่ 0x63 (99)
 * ; ใช้คำสั่ง M260 หลายคำสั่งด้วยอาร์กิวเมนต์ B<base 10> หนึ่งคำสั่ง
 * M260 A99 ; ที่อยู่ทาสเป้าหมาย
 *M260 B77 ; เอ็ม
 * M260 B97 ; ก
 * M260 B114 ; ร
 * M260 B108 ; ล
 * M260 B105 ; ฉัน
 * M260 B110 ; น
 * M260 S1 ; ส่งบัฟเฟอร์ปัจจุบัน
 -
 * ; ตัวอย่างที่ 2
 * ; ขอ 6 ไบต์จากอุปกรณ์สเลฟที่มีที่อยู่ 0x63 (99)
 *M261A99B5 ครับ
 -
 * ; ตัวอย่างที่ 3
 * ; ตัวอย่างเอาต์พุตแบบอนุกรมของคำขอ M261
 * echo:i2c-reply: จาก: 99 ไบต์: 5 ข้อมูล: สวัสดี
 -

//#กำหนด EXPERIMENTAL_I2CBUS
#ถ้าเปิดใช้งาน (EXPERIMENTAL_I2CBUS)
  #define I2C_SLAVE_ADDRESS 0 // ตั้งค่าตั้งแต่ 8 ถึง 127 เพื่อทำหน้าที่เป็นสเลฟ
#สิ้นสุด

// @ส่วนเสริม

-
 * ภาพถ่าย G-code
 * เพิ่ม G-code M240 เพื่อถ่ายภาพ
 * สามารถสั่งการถ่ายภาพได้ด้วยหมุดดิจิทัลหรือการเคลื่อนไหวทางกายภาพ
 -
//#กำหนด PHOTO_GCODE
#ถ้าเปิดใช้งาน (PHOTO_GCODE)
  // ตำแหน่งที่ต้องเคลื่อนที่ (และยก Z) ก่อนถ่ายภาพ
  //#define PHOTO_POSITION { X_MAX_POS - 5, Y_MAX_POS, 0 } // { xpos, ypos, zraise } (M240 XYZ)
  //#define PHOTO_DELAY_MS 100 // (ms) ระยะเวลาที่จะหยุดชั่วคราวก่อนจะเคลื่อนกลับ (M240 P)
  //#define PHOTO_RETRACT_MM 6.5 // (มม.) E หด/คืนตัวเพื่อเคลื่อนตัวถ่ายภาพ (M240 RS)

  // Canon RC-1 หรือ ทริกเกอร์กล้องดิจิตอลแบบโฮมเมด
  // ข้อมูลจาก : https://www.doc-diy.net/photo/rc-1_hacked/
  //#กำหนด PHOTOGRAPH_PIN 23

  // ชุดพัฒนาแฮ็ค Canon
  // https://captain-slow.dk/2014/03/09/3d-printing-timelapses/
  //#กำหนด CHDK_PIN 4

  // การเคลื่อนไหวที่สองที่เป็นตัวเลือกพร้อมการหน่วงเวลาเพื่อสั่งการชัตเตอร์กล้อง
  //#define PHOTO_SWITCH_POSITION { X_MAX_POS, Y_MAX_POS } // { xpos, ypos } (M240 IJ)

  // ระยะเวลาในการกดสวิตช์ค้างไว้หรือรักษา CHDK_PIN ให้สูง
  //#define PHOTO_SWITCH_MS 50 // (มิลลิวินาที) (M240 D)

  -
   * PHOTO_PULSES_US อาจต้องมีการปรับแต่ง ขึ้นอยู่กับบอร์ดและรุ่นของกล้อง
   * พินจะต้องทำงานที่ 48.4kHz
   * โปรดแน่ใจว่าได้ใช้ PHOTOGRAPH_PIN ที่สามารถขึ้นและลงได้อย่างรวดเร็วเพียงพอ
   * (เช่น พินเซนเซอร์อุณหภูมิ MKS SBase ช้าเกินไป ดังนั้นจึงใช้ P1.23 บน J8)
   -
   *ตัวอย่างข้อมูลพัลส์สำหรับ Nikon: https://bit.ly/2FKD0Aq
   * การเดินสาย IR: https://git.io/JvJf7
   -
  //#define PHOTO_PULSES_US { 2000, 27850, 400, 1580, 400, 3580, 400 } // (ตวินาที) ระยะเวลาสำหรับการแกว่งแต่ละครั้งที่ 48.4kHz
  #ifdef ภาพ_PULSES_US
    #define PHOTO_PULSE_DELAY_US 13 // (ตวินาที) ระยะเวลาโดยประมาณของพัลส์ HIGH และ LOW แต่ละพัลส์ในการแกว่ง
  #สิ้นสุด
#สิ้นสุด

-
 * การควบคุมแกนหมุนและเลเซอร์
 -
 * เพิ่มคำสั่ง M3, M4 และ M5 เพื่อเปิดและปิดแกนหมุน/เลเซอร์ และ
 * เพื่อตั้งค่าความเร็วของแกนหมุน ทิศทางของแกนหมุน และกำลังของเลเซอร์
 -
 * SuperPid คือตัวควบคุมความเร็วของเราเตอร์/แกนหมุนที่ใช้ในชุมชนการกัด CNC
 * มาร์ลินใช้เปิด-ปิดแกนหมุนได้ และยังใช้ตั้งได้
 * ความเร็วรอบแกนหมุนตั้งแต่ 5,000 ถึง 30,000 รอบต่อนาที
 -
 * คุณจะต้องเลือกพินสำหรับฟังก์ชันเปิด/ปิดและเลือก 0-5V เป็นทางเลือก
 * พินฮาร์ดแวร์ PWM สำหรับการควบคุมความเร็วและพินสำหรับทิศทางการหมุน
 -
 * ดู https://marlinfw.org/docs/configuration/laser_spindle.html เพื่อดูรายละเอียดการกำหนดค่าเพิ่มเติม
 -
//#กำหนด SPINDLE_FEATURE
//#กำหนด LASER_FEATURE
#ถ้า EITHER(SPINDLE_FEATURE, LASER_FEATURE)
  #define SPINDLE_LASER_ACTIVE_STATE LOW // ตั้งเป็น "HIGH" ถ้าฟังก์ชันเปิด/ปิดทำงานเป็น HIGH
  #define SPINDLE_LASER_PWM true // ตั้งเป็น "true" หากตัวควบคุมของคุณรองรับการตั้งค่าความเร็ว/พลังงาน
  #define SPINDLE_LASER_PWM_INVERT false // ตั้งเป็น "true" หากความเร็ว/กำลังเพิ่มขึ้นเมื่อคุณต้องการให้ช้าลง

  #define SPINDLE_LASER_FREQUENCY 2500 // (Hz) ความถี่แกนหมุน/เลเซอร์ (เฉพาะ HAL ที่รองรับ: AVR และ LPC)

  -
   * สามารถตั้งค่าความเร็ว/กำลัง ('M3 S') และแสดงผลได้ดังนี้:
   * - พีดับบลิวเอ็ม255 (S0 - S255)
   * - เปอร์เซ็นต์ (S0 - S100)
   * - RPM (S0 - S50000) เหมาะที่สุดสำหรับการใช้งานร่วมกับสปินเดิล
   -
  #กำหนดหน่วยจ่ายไฟ CUTTER_POWER_UNIT PWM255

  -
   * พลังการตัดสัมพันธ์
   * โดยปกติ 'M3 O<power>' จะตั้งค่า
   * กำลังของ OCR จะสัมพันธ์กับช่วง SPEED_POWER_MIN...SPEED_POWER_MAX
   * ดังนั้นกำลังไฟฟ้าเข้า 0...255 สอดคล้องกับ SPEED_POWER_MIN...SPEED_POWER_MAX
   * แทนช่วงปกติ (0 ถึง SPEED_POWER_MAX)
   * ใช้ได้ดีที่สุดกับตัวควบคุมเราเตอร์ SuperPID เช่น S0 = 5,000 RPM และ S255 = 30,000 RPM
   -
  //#define CUTTER_POWER_RELATIVE // ตั้งค่าความเร็วตามสัดส่วน [SPEED_POWER_MIN...SPEED_POWER_MAX]

  #ถ้าเปิดใช้งาน (SPINDLE_FEATURE)
    //#define SPINDLE_CHANGE_DIR // เปิดใช้งานหากตัวควบคุมแกนหมุนของคุณสามารถเปลี่ยนทิศทางของแกนหมุนได้
    #define SPINDLE_CHANGE_DIR_STOP // เปิดใช้งานหากแกนหมุนควรหยุดก่อนที่จะเปลี่ยนทิศทางการหมุน
    #define SPINDLE_INVERT_DIR false // ตั้งเป็น "true" ถ้าทิศทางการหมุนกลับด้าน

    #define SPINDLE_LASER_POWERUP_DELAY 5000 // (ms) หน่วงเวลาเพื่อให้สปินเดิล/เลเซอร์ทำงานด้วยความเร็ว/กำลัง
    #define SPINDLE_LASER_POWERDOWN_DELAY 5000 // (ms) หน่วงเวลาให้แกนหมุนหยุด

    -
     * สมการกำลัง M3/M4
     -
     * เครื่องมือแต่ละชิ้นใช้ช่วงค่าที่แตกต่างกันในการควบคุมความเร็ว/พลังงาน
     * พารามิเตอร์เหล่านี้ใช้เพื่อแปลงระหว่างหน่วยพลังงานเครื่องมือและ PWM
     -
     * ความเร็ว/กำลัง = (PWMDC / 255 * 100 - SPEED_POWER_INTERCEPT) / SPEED_POWER_SLOPE
     * PWMDC = (ความเร็วรอบ - SPEED_POWER_MIN) / (SPEED_POWER_MAX - SPEED_POWER_MIN) / SPEED_POWER_SLOPE
     -
    #define SPEED_POWER_INTERCEPT 0 // (%) 0-100 หรือ เปอร์เซ็นต์พลังงานขั้นต่ำ
    #define SPEED_POWER_MIN 5000 // (รอบต่อนาที)
    #define SPEED_POWER_MAX 30000 // (RPM) ตัวควบคุมเราเตอร์ SuperPID 0 - 30,000 RPM
    #define SPEED_POWER_STARTUP 25000 // (RPM) ความเร็ว/กำลังเริ่มต้นของ M3/M4 (ไม่มีอาร์กิวเมนต์)

  #อื่น

    #define SPEED_POWER_INTERCEPT 0 // (%) 0-100 หรือ เปอร์เซ็นต์พลังงานขั้นต่ำ
    #define SPEED_POWER_MIN 0 // (%) 0-100
    #define SPEED_POWER_MAX 100 // (%) 0-100
    #define SPEED_POWER_STARTUP 80 // (%) ความเร็ว/กำลัง M3/M4 ค่าเริ่มต้น (ไม่มีอาร์กิวเมนต์)

    -
     * เปิดใช้งานพลังงานเลเซอร์อินไลน์เพื่อจัดการในโปรแกรมวางแผน/สเต็ปเปอร์
     * พลังงานอินไลน์ระบุโดยแฟล็ก I (อินไลน์) ในคำสั่ง M3 (เช่น M3 S20 I)
     * หรือโดยพารามิเตอร์ 'S' ในการเคลื่อนที่ G0/G1/G2/G3 (ดู LASER_MOVE_POWER)
     -
     * ซึ่งช่วยให้เลเซอร์สามารถซิงก์กับเครื่องมือวางแผนได้อย่างสมบูรณ์แบบและลบออก
     * ความล่าช้าในการเปิด/ปิดเครื่อง เนื่องจากเลเซอร์ต้องใช้เวลาที่ไม่สำคัญ
     -
    #กำหนด LASER_POWER_INLINE

    #ถ้าเปิดใช้งาน (LASER_POWER_INLINE)
      -
       * ปรับขนาดกำลังของเลเซอร์ตามอัตราการเคลื่อนไหว
       -
       * - ตั้งค่ากำลังไฟฟ้าเข้าตามสัดส่วนของความเร็วเข้าเทียบกับความเร็วที่กำหนด
       * - เพิ่มกำลังทุกๆ N ขั้นเพื่อให้ใกล้เคียงกับความเร็วของรูปสี่เหลี่ยมคางหมู
       * - เนื่องจากความละเอียดพลังงานที่จำกัด นี่จึงเป็นเพียงค่าประมาณเท่านั้น
       -
      #กำหนด LASER_POWER_INLINE_TRAPEZOID

      -
       * คำนวณกำลังไฟปัจจุบันอย่างต่อเนื่อง (nominal_power * current_rate / nominal_rate)
       * จำเป็นสำหรับกำลังที่แม่นยำพร้อมการเร่งความเร็วแบบไม่เป็นรูปสี่เหลี่ยมคางหมู (เช่น S_CURVE_ACCELERATION)
       * นี่เป็นการคำนวณที่มีค่าใช้จ่ายสูง ดังนั้นจึงไม่ควรใช้ตัวเลือกนี้บนบอร์ด AVR 8 บิต
       -
       * LASER_POWER_INLINE_TRAPEZOID_CONT_PER กำหนดจำนวนรอบขั้นตอนระหว่างการอัปเดตพลังงาน หากคุณ
       * บอร์ดไม่สามารถสร้างขั้นตอนได้เร็วพอ (และคุณกำลังใช้ LASER_POWER_INLINE_TRAPEZOID_CONT) ให้เพิ่มค่านี้
       * หมายเหตุว่าเมื่อเป็นศูนย์ แสดงว่าเกิดขึ้นทุกรอบ 1 หมายถึงมีความล่าช้า รอหนึ่งรอบแล้วจึงดำเนินการ เป็นต้น
       -
      //#กำหนด LASER_POWER_INLINE_TRAPEZOID_CONT

      -
       * การวนซ้ำของสเต็ปเปอร์ระหว่างการอัปเดตพลังงาน เพิ่มค่านี้หากบอร์ด
       * ไม่สามารถรองรับความต้องการในการประมวลผลของ LASER_POWER_INLINE_TRAPEZOID_CONT ได้
       * ปิดการใช้งาน (หรือตั้งค่าเป็น 0) เพื่อคำนวณกำลังไฟฟ้าใหม่ในแต่ละการทำซ้ำของสเต็ปเปอร์
       -
      //#กำหนด LASER_POWER_INLINE_TRAPEZOID_CONT_PER 10

      -
       * รวมกำลังเลเซอร์ในคำสั่ง G0/G1/G2/G3/G5 ด้วยพารามิเตอร์ 'S'
       -
      //#กำหนด LASER_MOVE_POWER

      #ถ้าเปิดใช้งาน (LASER_MOVE_POWER)
        // ปิดเลเซอร์เมื่อเคลื่อนที่ G0 โดยไม่ใช้พารามิเตอร์กำลัง
        // หากมีการระบุพารามิเตอร์กำลัง ให้ใช้พารามิเตอร์นั้นแทน
        //#กำหนด LASER_MOVE_G0_OFF

        // ปิดเลเซอร์ในการโฮม G28
        //#กำหนด LASER_MOVE_G28_OFF
      #สิ้นสุด

      -
       * ธงอินไลน์กลับด้าน
       -
       *คำเตือน: M5 จะไม่ปิดเลเซอร์ เว้นแต่จะมีการเคลื่อนไหวอื่น
       * เสร็จเรียบร้อย (ไฟล์ G-code จะต้องลงท้ายด้วย 'M5 I')
       -
      //#กำหนด LASER_POWER_INLINE_INVERT

      -
       * จ่ายไฟอินไลน์อย่างต่อเนื่อง ('M3 S3' == 'G1 S3' == 'M3 S3 I')
       -
       * เลเซอร์อาจทำสิ่งแปลกๆ ได้ ดังนั้นให้เปิดใช้งานเฉพาะสิ่งนี้เท่านั้น
       *ฟีเจอร์นี้หากคุณเข้าใจถึงผลที่ตามมา
       -
      //#กำหนด LASER_POWER_INLINE_CONTINUOUS

    #อื่น

      #define SPINDLE_LASER_POWERUP_DELAY 50 // (ms) หน่วงเวลาเพื่อให้สปินเดิล/เลเซอร์ทำงานด้วยความเร็ว/กำลัง
      #define SPINDLE_LASER_POWERDOWN_DELAY 50 // (ms) หน่วงเวลาให้แกนหมุนหยุด

    #สิ้นสุด
  #สิ้นสุด
#สิ้นสุด

-
 * ระบบควบคุมน้ำหล่อเย็น
 -
 * เพิ่มคำสั่ง M7, M8 และ M9 เพื่อเปิดและปิดละอองน้ำหล่อเย็นหรือน้ำท่วม
 -
 * หมายเหตุ: ต้องกำหนด COOLANT_MIST_PIN และ/หรือ COOLANT_FLOOD_PIN ด้วย
 -
//#กำหนด COOLANT_CONTROL
#ถ้าเปิดใช้งาน (COOLANT_CONTROL)
  #define COOLANT_MIST // เปิดใช้งานหากมีน้ำหล่อเย็นแบบละอองน้ำ
  #define COOLANT_FLOOD // เปิดใช้งานหากมีน้ำหล่อเย็นท่วมขัง
  #define COOLANT_MIST_INVERT false // ตั้งค่า "true" ถ้าฟังก์ชันเปิด/ปิดสลับกัน
  #define COOLANT_FLOOD_INVERT false // ตั้งค่า "true" ถ้าฟังก์ชันเปิด/ปิดสลับกัน
#สิ้นสุด

-
 * เซ็นเซอร์ความกว้างของเส้นใย
 -
 * วัดความกว้างของเส้นใยแบบเรียลไทม์และปรับ
 * อัตราการไหลเพื่อชดเชยความไม่ปกติใดๆ
 -
 * ยังช่วยให้สามารถตั้งค่าเส้นผ่านศูนย์กลางของเส้นใยที่วัดได้
 * อัตราการอัดรีด ดังนั้นเครื่องหั่นจึงต้องระบุเพียง
 * ปริมาณ.
 -
 * ขณะนี้รองรับเครื่องอัดรีดเพียงเครื่องเดียว
 -
 * 34 RAMPS_14 : อินพุตอะนาล็อก 5 บนขั้วต่อ AUX2
 * 81 PRINTRBOARD : อินพุตอะนาล็อก 2 บนขั้วต่อ Exp1 (เวอร์ชัน B,C,D,E)
 * 301 RAMBO : อินพุตอนาล็อก 3
 -
 * หมายเหตุ: อาจต้องกำหนดพินอะนาล็อกสำหรับบอร์ดอื่น
 -
//#กำหนด FILAMENT_WIDTH_SENSOR

#ถ้าเปิดใช้งาน (FILAMENT_WIDTH_SENSOR)
  #define FILAMENT_SENSOR_EXTRUDER_NUM 0 // ดัชนีของหัวฉีดที่มีเซ็นเซอร์เส้นใย :[0,1,2,3,4]
  #define MEASUREMENT_DELAY_CM 14 // (ซม.) ระยะห่างจากเซ็นเซอร์เส้นใยถึงห้องหลอมละลาย

  #define FILWIDTH_ERROR_MARGIN 1.0 // (มม.) หากการวัดแตกต่างจากความกว้างที่กำหนดมากเกินไป ให้ละเว้นค่านี้
  #define MAX_MEASUREMENT_DELAY 20 // (ไบต์) ขนาดบัฟเฟอร์สำหรับการวัดที่เก็บไว้ (1 ไบต์ต่อเซนติเมตร) จะต้องมีขนาดใหญ่กว่า MEASUREMENT_DELAY_CM

  #define DEFAULT_MEASURED_FILAMENT_DIA DEFAULT_NOMINAL_FILAMENT_DIA // ตั้งค่าการวัดเป็นค่าปกติในตอนแรก

  // แสดงความกว้างของเส้นใยบนบรรทัดสถานะ LCD ข้อความสถานะจะหมดอายุหลังจาก 5 วินาที
  //#กำหนด FILAMENT_LCD_DISPLAY
#สิ้นสุด

-
 * มอนิเตอร์พลังงาน
 * ตรวจสอบแรงดันไฟ (V) และ/หรือกระแสไฟ (A) และเมื่อเป็นไปได้ กำลังไฟฟ้า (W)
 -
 * อ่านและกำหนดค่าด้วย M430
 -
 * เซ็นเซอร์กระแสไฟฟ้าจะป้อนแรงดันไฟฟ้า DC (เทียบกับกระแสไฟฟ้าที่วัดได้) ไปยังพินอนาล็อก
 * เซ็นเซอร์แรงดันไฟฟ้าจะป้อนแรงดันไฟฟ้า DC (เทียบกับแรงดันไฟฟ้าที่วัดได้) ไปยังพินอนาล็อก
 -
//#define POWER_MONITOR_CURRENT // ตรวจสอบระบบปัจจุบัน
//#define POWER_MONITOR_VOLTAGE // ตรวจสอบแรงดันไฟฟ้าของระบบ
#ถ้า EITHER(POWER_MONITOR_CURRENT, POWER_MONITOR_VOLTAGE)
  #define POWER_MONITOR_VOLTS_PER_AMP 0.05000 // แรงดันไฟฟ้าขาเข้าไปยังพินอะนาล็อก MCU ต่อแอมป์ - ห้ามใช้เกิน ADC_VREF!
  #define POWER_MONITOR_CURRENT_OFFSET -1 // ค่าออฟเซ็ตสำหรับเซนเซอร์กระแสไฟฟ้าที่มีเอาต์พุตฟังก์ชันเชิงเส้น
  #define POWER_MONITOR_VOLTS_PER_VOLT 0.11786 // แรงดันไฟฟ้าขาเข้าไปยังพินอนาล็อก MCU ต่อโวลต์ - ห้ามใช้เกิน ADC_VREF!
  #define POWER_MONITOR_FIXED_VOLTAGE 13.6 // แรงดันไฟฟ้าสำหรับเซ็นเซอร์กระแสไฟฟ้าที่ไม่มีเซ็นเซอร์แรงดันไฟฟ้า (สำหรับการแสดงพลังงาน)
#สิ้นสุด

-
 * ระบบพิกัด CNC
 -
 * เปิดใช้งานคำสั่ง G53 และ G54-G59.3 เพื่อเลือกระบบพิกัด
 * และ G92.1 เพื่อรีเซ็ตพื้นที่ทำงานไปยังพื้นที่เครื่องดั้งเดิม
 -
//#กำหนดระบบ CNC_COORDINATE_SYSTEMS

-
 * รายงานอุณหภูมิอัตโนมัติด้วย M155 S<วินาที>
 -
#กำหนดรายงานอุณหภูมิอัตโนมัติ

-
 * รวมความสามารถในเอาท์พุต M115
 -
#กำหนด EXTENDED_CAPABILITIES_REPORT
#ถ้าเปิดใช้งาน (EXTENDED_CAPABILITIES_REPORT)
  //#กำหนด M115_GEOMETRY_REPORT
#สิ้นสุด

-
 * การตรวจสอบเครื่องพิมพ์ที่คาดหวัง
 * เพิ่มรหัส G M16 เพื่อเปรียบเทียบสตริงกับ MACHINE_NAME
 * M16 ที่มีสตริงที่ไม่ตรงกันจะทำให้เครื่องพิมพ์หยุดทำงาน
 -
//#กำหนดการตรวจสอบเครื่องพิมพ์ที่คาดหวัง

-
 * ปิดใช้งานตัวเลือกการอัดรีดแบบปริมาตรทั้งหมด
 -
//#กำหนด NO_VOLUMETRICS

#ถ้าปิดใช้งาน (NO_VOLUMETRICS)
  -
   * สถานะเริ่มต้นของการอัดรีดแบบปริมาตร
   * เปิดใช้งานเพื่อให้การอัดรีดแบบปริมาตรเป็นวิธีเริ่มต้น
   * โดยมี DEFAULT_NOMINAL_FILAMENT_DIA เป็นเส้นผ่านศูนย์กลางเริ่มต้น
   -
   * M200 D0 เพื่อปิดใช้งาน M200 Dn เพื่อตั้งค่าเส้นผ่านศูนย์กลางใหม่ (และเปิดใช้งานระบบปริมาตร)
   * M200 S0/S1 เพื่อปิดใช้งาน/เปิดใช้งานการอัดรีดแบบปริมาตร
   -
  //#กำหนด VOLUMETRIC_DEFAULT_ON

  //#กำหนด VOLUMETRIC_EXTRUDER_LIMIT
  #ถ้าเปิดใช้งาน (VOLUMETRIC_EXTRUDER_LIMIT)
    -
     * ขีดจำกัดปริมาตรการอัดรีดเริ่มต้นเป็นลูกบาศก์มิลลิเมตรต่อวินาที (mm^3/วินาที)
     * การตั้งค่าจากโรงงานนี้ใช้กับเครื่องอัดรีดทั้งหมด
     * ใช้ 'M200 [T<extruder>] L<limit>' เพื่อแทนที่และ 'M502' เพื่อรีเซ็ต
     * ค่าที่ไม่เป็นศูนย์จะเปิดใช้งานการจำกัดการอัดรีดตามปริมาตร
     -
    #define DEFAULT_VOLUMETRIC_EXTRUDER_LIMIT 0.00 // (มม.^3/วินาที)
  #สิ้นสุด
#สิ้นสุด

-
 * เปิดใช้งานตัวเลือกนี้สำหรับการสร้าง Marlin แบบลีนที่ลบทั้งหมด
 * การชดเชยพื้นที่ทำงาน การลดความซับซ้อนของการแปลงพิกัด การปรับระดับ ฯลฯ
 -
 * - M206 และ M428 ถูกปิดใช้งาน
 * - G92 จะกลับไปสู่พฤติกรรมเดิมจาก Marlin 1.0
 -
//#กำหนด NO_WORKSPACE_OFFSETS

// ตัวเลือกเสริมสำหรับรายงาน "ตำแหน่งปัจจุบัน" ของ M114
#define M114_DETAIL // ใช้ 'M114` สำหรับรายละเอียดในการตรวจสอบการคำนวณของเครื่องมือวางแผน
//#define M114_REALTIME // ตำแหน่งปัจจุบันจริงตามจลนศาสตร์การเคลื่อนที่ไปข้างหน้า
//#define M114_LEGACY // M114 ใช้เพื่อซิงโครไนซ์ทุกครั้งที่โทร เปิดใช้งานหากจำเป็น

//#define REPORT_FAN_CHANGE // รายงานความเร็วพัดลมใหม่เมื่อมีการเปลี่ยนแปลงโดย M106 (และอื่นๆ)

-
 * กำหนดจำนวนช่องว่างแบบอักษรตามสัดส่วนที่จำเป็นในการเติมช่องว่างอักขระทั่วไป
 * นี้สามารถช่วยให้จัดเรียงเอาต์พุตของคำสั่งต่างๆ เช่น `G29 O` Mesh Output ได้ดีขึ้น
 -
 * สำหรับลูกค้าที่ใช้แบบอักษรความกว้างคงที่ (เช่น OctoPrint) ให้ตั้งค่าเป็น 1.0
 * มิฉะนั้นให้ปรับเปลี่ยนตามลูกค้าและแบบอักษรของคุณ
 -
#กำหนดอัตราส่วน PROPORTIONAL_FONT_RATIO 1.0

-
 * ใช้ SRAM 28 ไบต์เพื่อเพิ่มประสิทธิภาพตัววิเคราะห์ GCode
 -
#กำหนด FASTER_GCODE_PARSER

#ถ้าเปิดใช้งาน (FASTER_GCODE_PARSER)
  //#define GCODE_QUOTED_STRINGS // รองรับพารามิเตอร์สตริงที่มีเครื่องหมายคำพูด
#สิ้นสุด

//#define GCODE_CASE_INSENSITIVE // ยอมรับ G-code ที่ส่งไปยังเฟิร์มแวร์เป็นตัวพิมพ์เล็ก

//#define REPETIER_GCODE_M360 // เพิ่มคำสั่งจาก Repetier FW เดิม

-
 * ตัวเลือก CNC G-code
 * รองรับภาษา G-code แบบ CNC ที่ใช้ในเครื่องตัดเลเซอร์ เครื่องจักรกลวาดภาพ ฯลฯ
 * โปรดทราบว่าควรใช้ฟีดเรต G0 ด้วยความระมัดระวังในการพิมพ์ 3 มิติ (หากมีการใช้เลย)
 * อัตราการป้อนที่สูงอาจทำให้เกิดเสียงกริ่งและส่งผลเสียต่อคุณภาพการพิมพ์
 -
//#define PAREN_COMMENTS // รองรับความคิดเห็นที่คั่นด้วยวงเล็บ
//#define GCODE_MOTION_MODES // จำโหมดการเคลื่อนไหว (G0 G1 G2 G3 G5 G38.X) และใช้สำหรับ XYZEF เป็นต้น

// เปิดใช้งานและตั้งค่าฟีดเรท (เริ่มต้น) สำหรับการเคลื่อนที่ G0 ทั้งหมด
//#กำหนด G0_FEEDRATE 3000 // (มม./นาที)
#ifdef อัตราฟีด G0
  //#define VARIABLE_G0_FEEDRATE // อัตราป้อน G0 ถูกกำหนดโดย F ในโหมดการเคลื่อนไหว G0
#สิ้นสุด

-
 * คำสั่งเริ่มต้น
 -
 * ดำเนินการคำสั่ง G-code บางคำสั่งทันทีหลังจากเปิดเครื่อง
 -
//#กำหนด STARTUP_COMMANDS "M17 Z"

-
 * มาโคร G-code
 -
 * เพิ่ม G-code M810-M819 เพื่อกำหนดและรันมาโคร G-code
 * แมโครไม่ถูกบันทึกลงใน EEPROM
 -
//#กำหนด GCODE_MACROS
#ถ้าเปิดใช้งาน (GCODE_MACROS)
  #define GCODE_MACROS_SLOTS 5 // สามารถใช้ได้สูงสุด 10
  #define GCODE_MACROS_SLOT_SIZE 50 // ความยาวสูงสุดของแมโครเดี่ยว
#สิ้นสุด

-
 * รายการเมนูที่ผู้ใช้กำหนดซึ่งดำเนินการ GCode ที่กำหนดเอง
 -
//#กำหนดเมนูผู้ใช้ที่กำหนดเอง
#ถ้าเปิดใช้งาน (CUSTOM_USER_MENUS)
  //#define CUSTOM_USER_MENU_TITLE "คำสั่งที่กำหนดเอง"
  #define USER_SCRIPT_DONE "สคริปต์ผู้ใช้ M117 เสร็จสิ้น"
  #กำหนด USER_SCRIPT_AUDIBLE_FEEDBACK
  //#define USER_SCRIPT_RETURN // กลับสู่หน้าจอสถานะหลังจากสคริปต์

  #define USER_DESC_1 "หน้าแรกและข้อมูล UBL"
  #define USER_GCODE_1 "G28\nG29 ว"

  #define USER_DESC_2 "อุ่นเครื่องสำหรับ" PREHEAT_1_LABEL
  #define USER_GCODE_2 "M140 เอส" STRINGIFY(PREHEAT_1_TEMP_BED) "\nM104 เอส" STRINGIFY(PREHEAT_1_TEMP_HOTEND)

  #define USER_DESC_3 "อุ่นเครื่องสำหรับ" PREHEAT_2_LABEL
  #define USER_GCODE_3 "M140 เอส" STRINGIFY(PREHEAT_2_TEMP_BED) "\nM104 เอส" STRINGIFY(PREHEAT_2_TEMP_HOTEND)

  #define USER_DESC_4 "เครื่องทำความร้อน/โฮม/ระดับ"
  #define USER_GCODE_4 "M140 S" STRINGIFY(PREHEAT_2_TEMP_BED) "\nG28\nG29"

  #define USER_DESC_5 "หน้าแรกและข้อมูล"
  #กำหนด USER_G รหัส_5 "G28\nM503"
#สิ้นสุด

-
 * คำสั่งการดำเนินการโฮสต์
 -
 * กำหนดคำสั่งการดำเนินการของโฮสต์สตรีมเมอร์ให้เป็นไปตามมาตรฐาน
 -
 * ดู https://reprap.org/wiki/G-code#Action_commands
 * คำสั่งทั่วไป........ ปิดเครื่อง, หยุดชั่วคราว, หยุดชั่วคราว, ดำเนินการต่อ, ดำเนินการต่อ, ยกเลิก
 * G29_RETRY_AND_RECOVER .. การตรวจสอบการล้างข้อมูล, การตรวจสอบล้มเหลว
 -
 * คุณลักษณะบางอย่างเพิ่มรหัสเหตุผลเพื่อขยายคำสั่งเหล่านี้
 -
 * การรองรับ Host Prompt ช่วยให้ Marlin สามารถใช้โฮสต์สำหรับการแจ้งเตือนผู้ใช้ได้
 * การหมดเส้นใยและกระบวนการอื่นๆ สามารถจัดการได้จากด้านโฮสต์
 -
//#กำหนด HOST_ACTION_COMMANDS
#ถ้าเปิดใช้งาน (HOST_ACTION_COMMANDS)
  //#กำหนด HOST_PROMPT_SUPPORT
  //#define HOST_START_MENU_ITEM // เพิ่มรายการเมนูที่แจ้งให้โฮสต์เริ่มต้น
#สิ้นสุด

-
 * ยกเลิกวัตถุ
 -
 * นำ M486 มาใช้เพื่อให้ Marlin สามารถข้ามวัตถุได้
 -
//#กำหนด CANCEL_OBJECTS

-
 * ตัวเข้ารหัสตำแหน่ง I2C สำหรับการควบคุมแบบวงปิด
 * พัฒนาโดย Chris Barr ที่ Aus3D
 -
 * วิกิ: https://wiki.aus3d.com.au/Magnetic_Encoder
 * Github: https://github.com/Aus3D/MagneticEncoder
 -
 * ซัพพลายเออร์: https://aus3d.com.au/magnetic-encoder-module
 * ซัพพลายเออร์ทางเลือก: https://reliabuild3d.com/
 -
 * ตัวเข้ารหัส Reliabuild ได้รับการปรับเปลี่ยนเพื่อปรับปรุงความน่าเชื่อถือ
 -

//#กำหนด I2C_POSITION_ENCODERS
#ถ้าเปิดใช้งาน (I2C_POSITION_ENCODERS)

  #define I2CPE_ENCODER_CNT 1 // จำนวนตัวเข้ารหัสที่ติดตั้ง สูงสุด 5 ตัว
                                                            // ตัวเข้ารหัสที่รองรับในปัจจุบัน

  #define I2CPE_ENC_1_ADDR I2CPE_PRESET_ADDR_X // ที่อยู่ I2C ของตัวเข้ารหัส 30-200
  #define I2CPE_ENC_1_AXIS X_AXIS // แกนที่ติดตั้งโมดูลตัวเข้ารหัส <X|Y|Z|E>_AXIS
  #define I2CPE_ENC_1_TYPE I2CPE_ENC_TYPE_LINEAR // ประเภทของตัวเข้ารหัส: I2CPE_ENC_TYPE_LINEAR -หรือ-
                                                            // I2CPE_ENC_TYPE_ROTARY คือ:
  #define I2CPE_ENC_1_TICKS_UNIT 2048 // 1024 สำหรับแถบแม่เหล็กที่มีขั้ว 2 มม.; 2048 สำหรับ
                                                            // ขั้ว 1 มม. สำหรับตัวเข้ารหัสเชิงเส้นคือ ติ๊ก / มม.
                                                            // สำหรับตัวเข้ารหัสหมุน นี่คือ ติ๊ก / การปฏิวัติ
  //#define I2CPE_ENC_1_TICKS_REV (16 * 200) // จำเป็นสำหรับตัวเข้ารหัสหมุนเท่านั้น จำนวนสเต็ปเปอร์
                                                            // ขั้นตอนต่อรอบเต็ม (ขั้นตอนมอเตอร์/รอบ * ไมโครสเต็ป)
  //#define I2CPE_ENC_1_INVERT // ย้อนกลับทิศทางการเคลื่อนที่ของแกน
  #define I2CPE_ENC_1_EC_METHOD I2CPE_ECM_MICROSTEP // ประเภทของข้อผิดพลาด การแก้ไขข้อผิดพลาด
  #define I2CPE_ENC_1_EC_THRESH 0.10 // ขนาดเกณฑ์สำหรับข้อผิดพลาด (เป็นมม.) ที่สูงกว่า
                                                            // เครื่องพิมพ์จะพยายามแก้ไขข้อผิดพลาด; ข้อผิดพลาด
                                                            // ขนาดเล็กกว่านี้จะถูกละเว้นเพื่อลดผลกระทบของ
                                                            // การวัดสัญญาณรบกวน / ความหน่วงเวลา (ตัวกรอง)

  #define I2CPE_ENC_2_ADDR I2CPE_PRESET_ADDR_Y // เหมือนด้านบน แต่สำหรับตัวเข้ารหัส 2
  #กำหนด I2CPE_ENC_2_แกน Y_แกน
  #กำหนด I2CPE_ENC_TYPE I2CPE_ENC_TYPE_LINEAR
  #กำหนด I2CPE_ENC_2_TICKS_UNIT 2048
  //#กำหนด I2CPE_ENC_2_TICKS_REV (16 * 200)
  //#กำหนด I2CPE_ENC_2_INVERT
  #กำหนด I2CPE_ENC_2_EC_METHOD I2CPE_ECM_MICROSTEP
  #กำหนด I2CPE_ENC_2_EC_THRESH 0.10

  #define I2CPE_ENC_3_ADDR I2CPE_PRESET_ADDR_Z // ตัวเข้ารหัส 3. เพิ่มตัวเลือกการกำหนดค่าเพิ่มเติม
  #define I2CPE_ENC_3_AXIS Z_AXIS // เหมือนด้านบน หรือใช้ค่าเริ่มต้นด้านล่าง

  #define I2CPE_ENC_4_ADDR I2CPE_PRESET_ADDR_E // ตัวเข้ารหัส 4
  #กำหนด I2CPE_ENC_4_AXIS E_AXIS

  #define I2CPE_ENC_5_ADDR 34 // ตัวเข้ารหัส 5
  #กำหนด I2CPE_ENC_5_AXIS E_AXIS

  // การตั้งค่าเริ่มต้นสำหรับตัวเข้ารหัสที่เปิดใช้งาน แต่ไม่มีการตั้งค่าที่กำหนดไว้ข้างต้น
  #กำหนด I2CPE_DEF_TYPE I2CPE_ENC_TYPE_LINEAR
  #กำหนด I2CPE_DEF_ENC_TICKS_UNIT 2048
  #กำหนด I2CPE_DEF_TICKS_REV (16 * 200)
  #กำหนด I2CPE_DEF_EC_METHOD I2CPE_ECM_NONE
  #กำหนด I2CPE_DEF_EC_THRESH 0.1

  //#define I2CPE_ERR_THRESH_ABORT 100.0 // ขนาดขีดจำกัดสำหรับข้อผิดพลาด (เป็นมม.) ข้อผิดพลาดที่กำหนดใดๆ
                                                            // แกน หลังจากนั้นเครื่องพิมพ์จะยกเลิก แสดงความคิดเห็น
                                                            // ปิดการใช้งานพฤติกรรมการยกเลิก

  #define I2CPE_TIME_TRUSTED 10000 // หลังจากเกิดข้อผิดพลาดของตัวเข้ารหัส จะต้องไม่มีข้อผิดพลาดเพิ่มเติมอีก
                                                            // สำหรับระยะเวลาเท่านี้ (เป็นมิลลิวินาที) ก่อนการเข้ารหัส
                                                            // ได้รับความไว้วางใจอีกครั้งแล้ว

  -
   * ตำแหน่งจะถูกตรวจสอบทุกครั้งที่มีการเรียกใช้คำสั่งใหม่จากบัฟเฟอร์ แต่ในระหว่างการเคลื่อนที่เป็นเวลานาน
   * การตั้งค่านี้จะกำหนดเวลาการอัปเดตขั้นต่ำระหว่างการตรวจสอบ ค่า 100 จะทำงานได้ดีกับ
   * ข้อผิดพลาดในการคำนวณค่าเฉลี่ยเคลื่อนที่เมื่อพยายามแก้ไขเฉพาะการข้ามเท่านั้น ไม่ใช่การสั่นสะเทือน
   -
  #define I2CPE_MIN_UPD_TIME_MS 4 // (ms) เวลาขั้นต่ำระหว่างการตรวจสอบตัวเข้ารหัส

  // ใช้ค่าเฉลี่ยเคลื่อนที่เพื่อระบุข้อผิดพลาดที่เกิดขึ้นอย่างต่อเนื่องซึ่งบ่งชี้ถึงการข้าม ซึ่งตรงข้ามกับการสั่นสะเทือนและสัญญาณรบกวน
  #กำหนด I2CPE_ERR_ROLLING_AVERAGE

#สิ้นสุดหาก // I2C_POSITION_ENCODERS

-
 * จอยสติ๊กอนาล็อก
 -
//#กำหนดจอยสติ๊ก
#ถ้าเปิดใช้งาน(จอยสติ๊ก)
  #define JOY_X_PIN 5 // RAMPS: พินที่แนะนำ A5 บน AUX2
  #define JOY_Y_PIN 10 // RAMPS: พินที่แนะนำ A10 บน AUX2
  #define JOY_Z_PIN 12 // RAMPS: พินที่แนะนำ A12 บน AUX2
  #define JOY_EN_PIN 44 // RAMPS: พินที่แนะนำ D44 บน AUX2

  //#define INVERT_JOY_X // เปิดใช้งานหากทิศทาง X ย้อนกลับ
  //#define INVERT_JOY_Y // เปิดใช้งานหากทิศทาง Y ถูกย้อนกลับ
  //#define INVERT_JOY_Z // เปิดใช้งานหากทิศทาง Z ย้อนกลับ

  // ใช้ M119 กับ JOYSTICK_DEBUG เพื่อค้นหาค่าที่เหมาะสมหลังจากเชื่อมต่อ:
  #define JOY_X_LIMITS { 5600, 8190-100, 8190+100, 10800 } // นาที, เริ่มต้นเดดโซน, สิ้นสุดเดดโซน, สูงสุด
  #กำหนด JOY_Y_LIMITS { 5600, 8250-100, 8250+100, 11000 }
  #กำหนด JOY_Z_LIMITS { 4800, 8080-100, 8080+100, 11550 }
  //#กำหนด JOYSTICK_DEBUG
#สิ้นสุด

-
 * เมทริกซ์ดีบัก MAX7219
 -
 * เพิ่มการรองรับสำหรับ LED Matrix 8x8 ราคาประหยัดที่ใช้ชิป Max7219 เพื่อแสดงสถานะแบบเรียลไทม์
 * ต้องใช้สายสัญญาณ 3 เส้น มีตัวเลือกดีบักที่เป็นประโยชน์บางอย่างรวมอยู่ด้วยเพื่อสาธิตการใช้งาน
 -
//#กำหนด MAX7219_DEBUG
#ถ้าเปิดใช้งาน (MAX7219_DEBUG)
  #กำหนด MAX7219_CLK_PIN 64
  #กำหนด MAX7219_DIN_PIN 57
  #กำหนด MAX7219_LOAD_PIN 44

  //#define MAX7219_GCODE // เพิ่ม G-code M7219 เพื่อควบคุมเมทริกซ์ LED
  #define MAX7219_INIT_TEST 2 // รูปแบบการทดสอบเมื่อเริ่มต้น: 0=ไม่มี, 1=การกวาด, 2=การหมุนวน
  #define MAX7219_NUMBER_UNITS 1 // จำนวนหน่วย Max7219 ในเชน
  #define MAX7219_ROTATE 0 // หมุนจอแสดงผลตามเข็มนาฬิกา (เป็นทวีคูณของ +/- 90 องศา)
                                   // ตัวเชื่อมต่อที่: ขวา=0 ล่าง=-90 ด้านบน=90 ซ้าย=180
  //#define MAX7219_REVERSE_ORDER // หน่วยเมทริกซ์ LED แต่ละหน่วยอาจอยู่ในลำดับย้อนกลับได้
  //#define MAX7219_SIDE_BY_SIDE // บอร์ดชิปขนาดใหญ่ + เมทริกซ์สามารถเชื่อมต่อแบบเคียงข้างกันได้

  -
   * ตัวอย่างคุณสมบัติการดีบัก
   * หากคุณเพิ่มการแสดงการดีบักเพิ่มเติม ควรระวังไม่ให้เกิดการขัดแย้ง!
   -
  #define MAX7219_DEBUG_PRINTER_ALIVE // ไฟ LED ที่มุมของเมทริกซ์ 8x8 กะพริบเพื่อแสดงว่าเฟิร์มแวร์กำลังทำงาน
  #define MAX7219_DEBUG_PLANNER_HEAD 3 // แสดงตำแหน่งหัวคิวของตัววางแผนบนแถวเมทริกซ์ LED นี้และแถวถัดไป
  #define MAX7219_DEBUG_PLANNER_TAIL 5 // แสดงตำแหน่งท้ายคิวตัววางแผนบนแถวเมทริกซ์ LED นี้และแถวถัดไป

  #define MAX7219_DEBUG_PLANNER_QUEUE 0 // แสดงความลึกของคิวตัววางแผนปัจจุบันในแถวเมทริกซ์ LED นี้และแถวถัดไป
                                         // หากคุณพบปัญหาการสะดุด รีบูต ฯลฯ ตัวเลือกนี้สามารถเปิดเผยวิธีการได้
                                         // การปรับแต่งที่ทำกับการกำหนดค่าจะส่งผลต่อเครื่องพิมพ์แบบเรียลไทม์
#สิ้นสุด

-
 * รองรับการซิงค์ NanoDLP
 -
 * เพิ่มการรองรับสำหรับการเคลื่อนไหว Z แบบซิงโครไนซ์เมื่อใช้กับ NanoDLP การเคลื่อนไหวแกน G0/G1 จะแสดงผล "Z_move_comp"
 * สตริงเพื่อเปิดใช้งานการซิงโครไนซ์กับการเปิดรับแสงของโปรเจ็กเตอร์ DLP การเปลี่ยนแปลงนี้จะช่วยให้สามารถใช้
 * [[WaitForDoneMessage]] แทนที่จะเติม gcode ของคุณด้วยคำสั่ง M400
 -
//#กำหนด NANODLP_Z_SYNC
#ถ้าเปิดใช้งาน (NANODLP_Z_SYNC)
  //#define NANODLP_ALL_AXIS // เปิดใช้งานเอาต์พุต "Z_move_comp" ในทุกการเคลื่อนที่ของแกน
                              // พฤติกรรมเริ่มต้นจำกัดเฉพาะแกน Z เท่านั้น
#สิ้นสุด

-
 * รองรับ WiFi (Espressif ESP32 WiFi)
 -
//#define WIFISUPPORT // การจัดการ WiFi แบบฝังของ Marlin
//#define ESP3D_WIFISUPPORT // การจัดการ WiFi ของไลบรารี ESP3D (https://github.com/luc-github/ESP3DLib)

#ถ้า EITHER(WIFISUPPORT, ESP3D_WIFISUPPORT)
  //#define WEBSUPPORT // เริ่มเว็บเซิร์ฟเวอร์ (ซึ่งอาจรวมถึงการค้นพบอัตโนมัติ)
  //#define OTASUPPORT // รองรับการอัปเดตเฟิร์มแวร์แบบไร้สาย
  //#define WIFI_CUSTOM_COMMAND // ยอมรับคำสั่งกำหนดค่าคุณสมบัติ (เช่น WiFi ESP3D) จากโฮสต์

  -
   * หากต้องการตั้งค่า SSID / รหัสผ่าน WiFi เริ่มต้น ให้สร้างไฟล์ชื่อ Configuration_Secure.h ด้วย
   * ต่อไปนี้คือคำจำกัดความที่ปรับแต่งสำหรับเครือข่ายของคุณ ไฟล์เฉพาะนี้จะถูกแยกออกผ่าน
   * .gitignore เพื่อป้องกันไม่ให้รั่วไหลสู่สาธารณะโดยไม่ได้ตั้งใจ
   -
   * #define WIFI_SSID "รหัส SSID ของ WiFi"
   * #define WIFI_PWD "รหัสผ่าน WiFi"
   -
  //#include "Configuration_Secure.h" // ไฟล์ภายนอกพร้อม SSID / รหัสผ่าน WiFi
#สิ้นสุด

-
 * ปริฏลคา Multi-Material Unit v2
 * เปิดใช้งานใน Configuration.h
 -
#ถ้าเปิดใช้งาน (PRUSA_MMU2)

  // พอร์ตซีเรียลที่ใช้ในการสื่อสารกับ MMU2.
  // สำหรับ AVR เปิดใช้งานพอร์ต UART ที่ใช้สำหรับ MMU (เช่น mmuSerial)
  // สำหรับบอร์ด 32 บิต โปรดตรวจสอบ HAL ของคุณเพื่อดูพอร์ตซีเรียลที่พร้อมใช้งาน (เช่น Serial2)
  #กำหนด MMU2_SERIAL_PORT 2
  #กำหนด MMU2_SERIAL mmuSerial

  // ใช้การรีเซ็ตฮาร์ดแวร์สำหรับ MMU หากมีการกำหนดพินไว้
  //#กำหนด MMU2_RST_PIN 23

  // เปิดใช้งานหาก MMU2 มีมอเตอร์สเต็ปเปอร์ 12V (เฟิร์มแวร์ MMU2 1.0.2 ขึ้นไป)
  //#กำหนด MMU2_MODE_12V

  // G-code ที่จะดำเนินการเมื่อโพรบ MMU2 FINDA ตรวจพบการหมดของเส้นใย
  #กำหนด MMU2_FILAMENT_RUNOUT_SCRIPT "M600"

  // เพิ่มเมนู LCD สำหรับ MMU2
  //#กำหนด MMU2_MENUS
  #ถ้าเปิดใช้งาน (MMU2_MENUS)
    // การตั้งค่าสำหรับการโหลด/นำเส้นใยออกจากเมนู LCD
    // นี้เป็นสำหรับเครื่องอัดรีดแบบ Prลฏกา MK3 ปรับแต่งให้เหมาะกับฮาร์ดแวร์ของคุณ
    #กำหนด MMU2_FILAMENTCHANGE_EJECT_FEED 80.0
    #กำหนด MMU2_LOAD_TO_NOZZLE_SEQUENCE \
      { 7.2, 1145 }, \
      { 14.4, 871 }, \
      { 36.0, 1393 }, \
      { 14.4, 871 }, \
      { 50.0, 198 }

    #กำหนด MMU2_RAMMING_SEQUENCE \
      { 1.0, 1000 }, \
      { 1.0, 1500 }, \
      { 2.0, 2000 }, \
      { 1.5, 3000 }, \
      { 2.5, 4000 }, \
      { -15.0, 5000 }, \
      { -14.0, 1200 }, \
      { -6.0, 600 }, \
      { 10.0, 700 }, \
      { -10.0, 400 }, \
      { -50.0, 2000 }
  #สิ้นสุด

  -
   * เซ็นเซอร์หัวฉีด MMU
   -
   * รองรับเซ็นเซอร์ IR Prลฏา (หรืออื่น ๆ ) เพื่อตรวจจับเส้นใยใกล้หัวฉีด
   * และทำให้การโหลดมีความน่าเชื่อถือมากขึ้น เหมาะสำหรับเครื่องอัดรีดที่ติดตั้งเส้นใย
   * เซ็นเซอร์ห่างจากเฟืองน้อยกว่า 38 มม.
   -
   * ในระหว่างการโหลด หัวฉีดจะหยุดทำงานเมื่อเซ็นเซอร์ถูกกระตุ้น จากนั้นจึงทำขั้นตอนสุดท้าย
   * ขยับขึ้นไปที่เกียร์ หากไม่พบเส้นใย MMU2 จะสามารถลองอีกครั้งได้
   * หากความพยายามทั้งหมดล้มเหลว เส้นใยจะหมดลง
   -
  //#กำหนด MMU_EXTRUDER_SENSOR
  #ถ้าเปิดใช้งาน (MMU_EXTRUDER_SENSOR)
    #define MMU_LOADING_ATTEMPTS_NR 5 // จำนวนสูงสุดของความพยายามในการโหลดเส้นใยหากการโหลดครั้งแรกล้มเหลว
  #สิ้นสุด

  -
   * ใช้เซ็นเซอร์เช่น MMU2S
   * โหมดนี้ต้องใช้เครื่องอัดรีด MK3S ที่มีเซ็นเซอร์อยู่ที่ล้อเลื่อนของเครื่องอัดรีด เช่น MMU2S
   * ดู https://help.prusa3d.com/en/guide/3b-mk3s-mk2-5s-extruder-upgrade_41560 ขั้นตอนที่ 11
   -
  //#กำหนดโหมด PRUSA_MMU2_S
  #ถ้าเปิดใช้งาน (PRUSA_MMU2_S_MODE)
    #define MMU2_C0_RETRY 5 // จำนวนการลองใหม่ (เวลาทั้งหมด = หมดเวลา*การลองใหม่)

    #define MMU2_CAN_LOAD_FEEDRATE 800 // (มม./นาที)
    #กำหนด MMU2_CAN_LOAD_SEQUENCE \
      { 0.1, MMU2_CAN_LOAD_FEEDRATE }, \
      { 60.0, MMU2_CAN_LOAD_FEEDRATE }, \
      { -52.0, MMU2_CAN_LOAD_FEEDRATE }

    #define MMU2_CAN_LOAD_RETRACT 6.0 // (มม.) ให้คงระยะห่างระหว่างค่าลำดับโหลด
    #define MMU2_CAN_LOAD_DEVIATION 0.8 // (มม.) ค่าเบี่ยงเบนที่ยอมรับได้

    #define MMU2_CAN_LOAD_INCREMENT 0.2 // (mm) เพื่อนำมาใช้ซ้ำภายในโมดูล MMU2
    #กำหนด MMU2_CAN_LOAD_INCREMENT_SEQUENCE \
      { -MMU2_CAN_LOAD_INCREMENT, MMU2_CAN_LOAD_FEEDRATE }

  #สิ้นสุด

  //#define MMU2_DEBUG // เขียนข้อมูลการดีบักไปยังเอาท์พุตแบบอนุกรม

#สิ้นสุด // PRUSA_MMU2

-
 * การตั้งค่าตัวนับการพิมพ์ขั้นสูง
 -
#ถ้าเปิดใช้งาน (PRINTCOUNTER)
  #กำหนดSERVICE_WARNING_BUZZES 3
  // เปิดใช้งาน Watchdog ช่วงเวลาการให้บริการสูงสุด 3 รายการ
  //#define SERVICE_NAME_1 "บริการ S"
  //#define SERVICE_INTERVAL_1 100 // ชั่วโมงการพิมพ์
  //#define SERVICE_NAME_2 "บริการ L"
  //#define SERVICE_INTERVAL_2 200 // ชั่วโมงการพิมพ์
  //#define SERVICE_NAME_3 "บริการ 3"
  //#define SERVICE_INTERVAL_3 1 // พิมพ์ชั่วโมง
#สิ้นสุด

// @ส่วนพัฒนา

-
// M100 Free Memory Watcher สำหรับดีบักการใช้งานหน่วยความจำ
-
//#กำหนด M100_FREE_MEMORY_WATCHER

-
// M42 - ตั้งค่าสถานะพิน
-
//#กำหนด DIRECT_PIN_CONTROL

-
// M43 - แสดงสถานะพิน พินสลับ พินนาฬิกา จุดหยุดนาฬิกา และไฟ LED สลับ โพรบทดสอบเซอร์โว
-
//#กำหนด PINS_DEBUGGING

// เปิดใช้งานโหมดพัฒนา Marlin ซึ่งเพิ่มคำสั่งพิเศษบางอย่าง
//#กำหนด MARLIN_DEV_MODE
